<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>shell学习</title>
    <url>/2024/04/28/shell%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="什么是shell">什么是Shell?</h2>
<p>Shell是一种用户与计算机进行交互的文字接口，也是一种脚本语言。</p>
<hr>
<h2 id="shell有什么用？">Shell有什么用？</h2>
<p>允许用户执行程序，查找文件，操作文件，输入并获取某种半结构化的输出</p>
<hr>
<h2 id="shell的使用">Shell的使用</h2>
<p>注意：此教程使用于类Unix shell，例如 Bash 或 ZSH，所以如果你的电脑是Mac或者Linux系统，则可以直接开始学习。<br>
如果您的电脑是Windows系统，请使用Wsl或者Linus虚拟机。</p>
<h4 id="在shell中导航">在Shell中导航</h4>
<p>shell中的路径时一组被分割的目录，<code>/</code>代表系统的根目录。</p>
<p>路径分为相对路径与绝对路径。</p>
<p>相对路径指的是相对当前的目录的路径，当前工作目录可以用<code>pwd</code>命令来获取。</p>
<p>绝对路径都是以<code>/</code>开头，可以认为是仅凭借绝对路径就能够找到文件的位置(相对路径无法做到这一点)</p>
<p>在相对路径表示中,<code>.</code>表示当前目录，<code>..</code>表示上级目录。</p>
<p>切换工作目录用<code>cd</code>操作来完成，格式为<code>cd 路径</code></p>
<p>下面举几个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd .. # 进入上级目录<br>pwd # 显示当前目录<br>/mnt/d/Onedrive # 当前目录<br> cd ./桌面 # 进入桌面目录<br>pwd # 查看当前目录<br>/mnt/d/Onedrive/桌面 # 当前目录<br></code></pre></td></tr></table></figure>
<p>以上操作完成了切入桌面这一目录的操作。</p>
<hr>
<h4 id="ls命令">ls命令</h4>
<p>作用：查看指定目录下包含哪些文件。</p>
<p>语法：<code>ls 路径</code></p>
<p>如果没有指定参数，ls打印当前目录下的文件</p>
<hr>
<h4 id="标记和选项">标记和选项</h4>
<p>什么是标记和选项呢？它们以<code>-</code>开头，可以改变程序的行为。</p>
<p>通常，在执行程序的时候使用<code>-h</code>或者<code>-help</code>来打印帮助信息。</p>
<p>下面举一个使用标记和选项的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -l ./文件夹合集<br></code></pre></td></tr></table></figure>
<p>通过<code>ls -help</code>中的帮助信息可以知道<code>ls -l</code>的作用是更加详细地列出目录文件或文件夹下的信息。</p>
<p>当我输入这个指令后，交互界面会打印出例如以下的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">drwxrwxrwx 1 borwin borwin 4096 Mar 15 01:15  my_python<br>drwxrwxrwx 1 borwin borwin 4096 Mar  9 22:29  pytorch学习<br></code></pre></td></tr></table></figure>
<p>前面一串字符串中d表示文件夹合集是一个目录，然后接下来的九个字符，每三个字符一组(rwx),它们分别代表了文件所有者、用户组以及其它所有人具有的权限。</p>
<p>r代表可读权限，w代表可写权限，x代表可执行权限(搜索权限)，如果不具有该权限，系统会打印出<code>r-x</code>之类的字符串，代表不具有修改权限。</p>
<hr>
<h4 id="mv命令">mv命令</h4>
<p>作用：为文件或者目录重命名，或者将文件或目录移动到其它位置。</p>
<p>语法：<br>
<code>mv [options] source dest</code></p>
<p><code>mv [options] source... directory</code></p>
<p>对options中的参数说明：</p>
<ul>
<li>-b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。</li>
<li>-i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。</li>
<li>-f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。</li>
<li>-n: 不要覆盖任何已存在的文件或目录。</li>
<li>-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</li>
</ul>
<p>mv参数的设置与运行结果一般有以下几种情况：</p>
<table>
<thead>
<tr>
<th>参数的设置</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>mv source_file(文件) dest_file(文件)</td>
<td>将源文件名 source_file 改为目标文件名 dest_file</td>
</tr>
<tr>
<td>mv source_file(文件) dest_directory(目录)</td>
<td>将文件 source_file 移动到目标目录 dest_directory 中</td>
</tr>
<tr>
<td>mv source_directory(目录) dest_directory(目录)</td>
<td>目录名 dest_directory 已存在，将 source_directory 移动到目录名 dest_directory 中；目录名 dest_directory 不存在则 source_directory 改名为目录名 dest_directory</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="cp命令">cp命令</h4>
<p>作用:复制文件或者目录(包含粘贴操作)</p>
<p>语法：<code>cp [options] source dest</code></p>
<p>对options中的参数加以说明：</p>
<ul>
<li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。</li>
<li>-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。</li>
<li>-r 或 --recursive：用于复制目录及其所有的子目录和文件，如果要复制目录，需要使用该选项</li>
<li>-i 或 --interactive：在复制前提示确认，如果目标文件已存在，则会询问是否覆盖，回答 y 时目标文件将被覆盖。</li>
<li>-u 或 --update：仅复制源文件中更新时间较新的文件。</li>
<li>-v 或 --verbose：显示详细的复制过程。</li>
<li>-p 或 --preserve：保留源文件的权限、所有者和时间戳信息。</li>
<li>-f 或 --force：强制复制，即使目标文件已存在也会覆盖，而且不给出提示。</li>
<li>-l：不复制文件，只是生成链接文件。</li>
</ul>
<p>下面举几个例子：</p>
<table>
<thead>
<tr>
<th>参数的设置</th>
<th>运行的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>cp file.txt /path/to/destination/</td>
<td>将文件 file.txt 复制到目录 /path/to/destination/ 中</td>
</tr>
<tr>
<td>cp –r test/ newtest</td>
<td>将当前目录 test/ 下的所有文件复制到新目录 newtest 下</td>
</tr>
<tr>
<td>cp -i file.txt /path/to/destination/</td>
<td>复制文件，并在目标文件已存在时进行确认</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="mkdir命令">mkdir命令</h4>
<p>作用：创建目录</p>
<p>语法：<code>mkdir [-p] dirName</code></p>
<p>参数说明：-p 确保目录名称存在，不存在的就建一个。</p>
<p>参数设置与运行结果：</p>
<table>
<thead>
<tr>
<th>参数的设置</th>
<th>运行的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>mkdir runoob</td>
<td>在工作目录下，建立一个名为 runoob 的子目录</td>
</tr>
<tr>
<td>mkdir -p runoob2/test</td>
<td>在工作目录下的 runoob2 目录中，建立一个名为 test 的子目录,若 runoob2 目录原本不存在，则建立一个</td>
</tr>
</tbody>
</table>
<p>注意：在上面的第二个例子中若不加 -p 参数，且原本 runoob2 目录不存在，则产生错误。</p>
<hr>
<h4 id="用户手册">用户手册</h4>
<p>如果想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，可以用<code>man</code>程序查看其用户手册。</p>
<p>例如<code>man ls</code>就能查看<code>ls</code>程序的用户手册</p>
<hr>
<h4 id="在程序之间创建连接">在程序之间创建连接</h4>
<p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！</p>
<p>最简单的两种重定向是<code>&lt; file</code>与<code>&gt; file</code>,分别为程序的输入重定向与输出的重定向</p>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">missing:~$ echo hello &gt; hello.txt<br>missing:~$ cat hello.txt<br>hello<br>missing:~$ cat &lt; hello.txt<br>hello<br>missing:~$ cat &lt; hello.txt &gt; hello2.txt<br>missing:~$ cat hello2.txt<br>hello<br></code></pre></td></tr></table></figure>
<p>除此之外，还可以使用<code>&gt;&gt;</code>来进行文件的最佳操作（即在文件的末尾追加内容）</p>
<p>重定向还可以依赖于管道<code>|</code>来将一个程序的输出于另一个程序的输入连接起来</p>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">missing:~$ ls -l / | tail -n1<br>drwxr-xr-x 1 root  root  4096 Jun 20  2019 var<br>missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#x27; &#x27; -f2<br>219<br></code></pre></td></tr></table></figure>
<hr>
<h4 id="sudo命令">sudo命令</h4>
<p>作用:以管理者的身份来执行程序，不会受到权限的限制</p>
<hr>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>基础工具</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>一些日常的碎碎念</title>
    <url>/2024/04/18/diary/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="aa0a7ed6bd698b19b17b99121a0aeb4465900088f46d65e7c9474b8cbc62fbc0">a6c09174f42c2996d998264a07e1ffbfe749e3aa27c4bdaa2d3499a4226b96c45d4ceb88c94a9428bd5cdc02d9e1f43d7a9c3ad307f3f22c48df2e946ddee197996423cf18f02524ff0fe95c69fd19b53c39832dd225ec276d5d917f934588b6221b36bfe0a80bd5763df9d7bce805fc04c8ca5e78ff22938ac473ac1fdd3f9f90732bb3aad6f8678839fc6e46a29466783995214d6ad61150712e9e00351490f5462f59750262d1794a30ab734993004d7aafe9e81273804d80a414f6c40fe1950dd5286bf177fbffbd93b344bf9b4c38ab480e604c984830a3803e8350b2456332b66f373de69d242fac99655f625156223d2e11eb3244875f55fb40c46fa8309960ecab751df2af711f67d3388eaeaa1a61c043b050e5f097443a933f5d00a8bda7c9e3f8e839b1b25ded75b5fe50e0a40d58eac3e5268fee9223ebeb9569c4ae6a2c4cb6f3aed4b2fd2defafef404478b0ddb56c5cead2a5ee71f1bee763412bfe95e6857445d53ed615a566ff5170a6bb667ed52539f38df93cf987b9db66488c3ae9c5982d6bc2732e61a210af15caa46df757862ae8d1aa381b112dd014444d13ef1653eeae175e6274876ac9ed9cfcf2c4aebf7e4491f377c657c04347843c6344eb1b08887c4165710f6ba507cd4bef07ac41e8a0ebe41890921b7911882d1227d7573e2ab5c6be258c66e6b38f71e0235eb366c31ae7a9218d259de5e0c42a8ee6d58a52ba91a89a5dc388f15602e93ede36e68e57ea0021a3eba8ae53cdb49b153816362fe7304a92bf07af32565948ec7ce59c8e95e671d4b10429733991db01d526fe4863aca8078f745602743bacfb7ea67650051595dd398a89aeb9445ed4611bd721160a1da66d1fb78dec5985a94e9fe57938dfc24db48b5663c84c02771248ce4f0b62a54916d1a9c50f7980c5b64043683a9e0a4a4b9600809411b6000fde2494289918687f14314e933abae1e819c22a7599d587ecc85d2b482833c271bc784749b16f07ad485667fc39fccb207c54620b3a947843aa966c168b799dd05a1902ba64196f2321b1036a353cb09c7f78cb7379aef6fe4895adcdcd5257d518bf10c3e5aecdfb170dce6d3f784b26211e10c3585a756f2ab80316af1953bc15423f412aa4d060da7231d87178ef949635de06a037b01e7e2f70376b8d90f4422606d95a6d4abb19d565db3fe935748a84c0d8f3d757714138602b53e3afa7417e632106786cc781cf418d92d813fa32bb5c12a284d8d258be4302d7ea7a569645805431fbf0f0e08e8476981a753185983735bd885992d850a85a758ba830fd2658d7c22dcd652518f837adedfbc7c5fbaa2a55dd293a80c1121ca7ea390cc029f9d571a23b781028e5b86704d865d65da6a1be9c0b9097816f2ca645edaec69addef9412d4f672256c302f107d29d069fb9a3edbd9a9fd8c037434fd24db5a91ce85ad9854c9d4df45f87d8881b04fa9f74dff0dcf7502bc31ea5f8d1d50163ed4ac62296545a23d208f6c835d4309660ffe3f3c084810ca45943fdd1f92c396fe7fe1187f673b6a4d4cf1c217a08f75abe247087164f9aa0474fb85b8f87499d4576644155abb28ba54e7d70ec50e2f9586ef4d4788df14a444149d2afed6b515888681ce62bd26dcd187b3c26c8797164930ced095c96f2aa08ba14630e7d042dfef5eb4fd5d2ebecf37cc83779ea04d932395f90392ec60fbdd69cca8e55548381cf83f3014ffd86b68c868970db60bed699e2498827a03c0ffd8417fb2d6afa02864a11245581046533a4b76b5c5a87955d6d0ae7e8388cf46b042cfc12ce1048c02b9ba5742d3cfb49e6072ab0ff3bdb718827c7bde9eb643f9ed5fee3c78f2234a10837ffa45f1912910e414c74b08d121f55e0a19ec7e10e8b76bcaaf93d6992222cebf154bd62b5f6e351ce8b1c17bccc14112b627aa1c9795683a5f2e4c88fe742d086fbf10bb0a87038aa819cf3aeccc4c706982e6c09f43e8be9be65ea167fa6eb69fd3ca51966734346a2c56970a8e101f8b967126cb535b40c74e114aa5cc30fbef6a3824ee8dfa24c7ef87680fb8a7951ba5c794df864678c93e537b4834698f132cf9c40aaf9c376b12a5c5e2b4cfe8aef853614fe99e9b9bde65a75e7f5d2cb7fff3dcb590f612e269ef8ef669715966ccb171f140cf5db457a0439f67303152bca9a64fae5855ea55f6333848c54800f0258583f2dc3adb56c1568edbfdf104d3445f7bcabd1d21b997100b0b94dce997cfa07b78a1e5b24cd6addc31a98c2bf7a6da029aed3617f42d947954d14563fd0c435678cb38d33330f04ad7efed9783ba94ec4c1b3565a45b555f5ff5bbee874fde47f84143506a89998c9a17cf8b01da8b00c7c01c011c1f31007de60a73b5f05cae56ffffd36d4267769e789c3d8170c6c75c769fd2b9788ecae51c22650fbfe828062991cf82b3d0ecf754065faaaac1faf428a657ed73b78ec0c22fc77df854b835695d9637cdf999f832a066691462e5e21333949deb1c8251371dcad74fe1228a695e17c7200704413ec78c8de1e9b91903893846467efe3b9b28b374928ee387f1dcb5208a5a6df50c6417e031a16f7d783eb28afdff3e03cd77fa7b8b691c29286b7916840fd499ed18516663277b77479af338437a50ebe9f9b982ff66c5ca35bbe6162487911a78305e6f5b199f9d906c673e6104236e99aadfb4de4704fb59f79f516dad719295715621c9565b2ebf1786dce114ae0ebcc8075a6c7d3619f0833e37e984b80bc468852bd0569ee00c6fb53a6139a7830efd399b52d96c8240368a11096f71592344ec77bd5d04e564d3d235123a687ba7be0aeb0886e3c46a5d239971a037dc56b90cfcbfb69d500cb61faccdd0d6b23be3ea04bea9c5d4fc55c14ecfae31575f1c9ef0231a039f59350b3f44892594430601ed391b749546373346538b9721dc1fcc2b09bf34d8c81b129c91cab3bff101c5c9d1e9e6a565db9a70c18adfdff165ac9c7273f787edbedc77b9c4b435144a63621be057b4e6ad955835772062dfc4ad32de7d1d0ac3ef4d90c61eee7e481e258c9d677223daf485bae72d6253dbe498ac2575aef16fe4c8913c8665cb302cd10a628d1002c944dc4943fd9f2d2d0723df94ef3ccc6dc0cae073c83494e1379daaef4a78cb084d5f954aa4563a0841b5e4a7fb43ca4362fddb3c8399fb9107e40cab1170127b39b14dac6974e2ff66246f00a667cd2742d3f75004084d57d0343e12592dd17e836c21622021a956c835c26f80d4f1d70e2061b200a9f542c4e741b36a5db166322f0aa08b1962ca100991fa2cf3d6e769c1f5ed56d84af8aaa8312979e4afb3bac7d206d9e87017cd6f72865c68cdcd04918c1034d9cf5b29b7cbacffa86d59f83765fb40766e97d1b0df0201c9cafd1a9f9bc344cf9d663e1c0870635b5a155b2cab4494483ec7ebb6157f2ad8cee1cecf9e2a037362d64cbc7668913605b9f3b3475abbb8032ba5c0a55fbab2b64568f27895ec3aff742486df680c5f2fb151da73775453c87a6c78d18e6bfdd1240f25b33c00f8edb35ed1bf589af803a0ddfba87e0311e9484628fd1a0f22ce99f110c6440a90d4e4bca0cec925c7a3814d0c1c23d7b2f48ca533d80b7647159be920c52ac293e0f5cfa728fc28aa8a9dd8f647b77b11e0a14b789a91e33e4b1182a471a000ff0f93ec1b5bcdde111f621d09ad17674a0f8f60b0e74e7f39c6504c707ad54a3a2a1ef1a0bc53988757e2791ba06f1e80c264502db78f3603cc4cffdea326cbd684831424f576e90e8d6e589ad5fcfc2297a275d6d43406540d2313f180609590310b44bfc5e73873c397baf9b40a0a82c4e648586a40f731add07c9b9a7de228de67da6439c3a8d715f90f154c57b15d62185d9e9dd450a3d29f4075bb2b186a0f9b8c6e727ecef08adc242f12c442c33316663fa7055b501dae953aac061c610b1d9cda99ffb722d8b172b9fb5d1726c02ee2a09cac3eac27830019783e391cdeed0cc4fd70f6eb250e7676033744d412cb2688910dbc6cb6e192c2a4dbc4e881bf8264e46df4c33ec39fb8e3eb39a55b04ce79a5743d7469449ba6d520b25dd11910504879dd007cb6ad36dbaab639bb61b33f865ec92ba680e3ac24136b019ae1144e2934cd56d6fc8c9010b50050ae06b0539a767753147d3515484e7b3b5367425c23a9930bc6aae724a12a01d3832bc2ad019bed49c7925f20b3a2a1d043a54db415c0bc317fd38dc96a0e7893cbd75ac7aaa2fe1766fb0e78985a3f122fc54442917d22b65b0060f6d7583fff46be8bd3c20ebca657dbe206513e3874b477b11bd6753fc90ed5c19a3df38cc44591ddda25f7e8ea7828ef6f6a64df51bde05089f9b5afc364f4e94aa4a706ae1f2e54d58da5611aa701783761d2cb4faf7b95a4c9c59a76af39faf0be705eb4562fb560881c13c65da43f58af9604051c8d33a849220d7cffb920a052c5e89e1bec72df9691b3d31d2076760fd013b4430ee8865af69e63da551ec8c5d5bbfae1f8481c563f285a94ecae2500002b789ac2c601db7483ddd2f889613b782e550228df80e880a0be2fa2dc48963d719c6a58d01d80afb09f3c2d37d66541e2c3ca15139759359783ff7ce988b8e567094f283fd4aeef95056655a96e07bf9314414e8642c540d6bff541ea74fb75655237412ab0e64a6946df07a7120e4404145c766ddfd32849d9c39f434df1bdd04818fac721d1bc2f7cc862c8816bc1998b5d0bd9d6b0d9f6a9cf22123344688addfb44c2046b36f4114bceaf06b710373958cae9b0c37593cfac73f4695b9ed5389804606accdd4b533a59575006b60a06e32b19fb9d9491f51963d485490a0a04c118132e96c6c785a1fd680eb455c4b05dd0a6461c6a8026b42be2d358782ea8413b58d2d58bd6c9e2b17edd286910a0ade2d5c9846e9c6195618323e9fc680346f1cc96000b22650a07e1e2fd9c383a3f927f869e1ece71a510ce71ec09864ec57caf66f9884979583f96befb8d1f8cf89ca1898f03ea96f80877f3d802bbaa85b645606f76df7da194ebe2818fa0a6baec602703690285f40dfe9e58741a9c20a3a5f175be0953f2a2672075d9394c77457c8f41d7b23e30f6290f5936c7ec0c9d52cd76ae0bef46410ac368a06d2071adef516f1f943aacb43ce5b94d2d8a0b94e2e7b316f84955de511d9d0ce8e30b3f754963c9c67307d8441edad0f24d999ef4cc60c12eee18cc71da25caf4c9d88a388ad6f3d3758d7230b3b3166e5beb6860fad8882c5b1e87a685264088bb6cda35d7e4f247ee9a89a1851796cc2603cddd09d4fb1ddfa93e043d85bf0fb78525d049b518bd621561a9ebd4c1af65207484079993350021d74bf9f19498420b8472c732dd87e5d87bf6d6ce807ee1ac0f3463b37929acb2e526df5c93996a3366ae740da5af33e9c38caa55713c841f07862fef7f8c9a8fa5a0be2dc62ea9f2c3689bef72ebaee3793e57396e27fb3a5dfe4bd1b315dc3479223aa51fb000eacd882ba825cb74da6fd983e9a00b1181a6de59b36b50b10bfb38577afbfe11e11e2c54c2348840e8850ced60936f3a9e7149c7c19dfcc8fb2182beb9b6f433153d5214580a983944348aeca70b690b2d20ec4cc872acd3f1ce3c836a264f0ada364d3f202b02db225262eb6e4bc0a00112a60bb8f6f0488c8760f1de00fad4f428de80bf5c88ec3f4a9416ccb2b9abc4b5b3d23b0b18fd8925a25796cd278a2ef9df6684484770bcc83665566bf602a4506fcc4c442c99c97b15161e8ef74efe7b4c9b134e1478cca58de3cca872257f4dd03dd7ba1ff4b716cc9cd65da751b63b87158940a8acb5c29bc917576b42c29b093ee069f47b198a309bd19aaf430457abbfb04f47e4fac5a7d677cb1d8b87fe9b3083990781f8379869baf9b7dba99ecfd6c91a456191dc6f0747ea9028870f12d874eda12d4ce58e26b007a131d69edfae4b9338e8d7bbbfcf4e381df4d8f74e8b07e18ee5096154942bc1f3b8fc19ef1436764b01dcbe4e056e5348a34f02c89341a7b7ac28bf55c6ad25257db1065677e2989db116150fb65f49d721f2437cc98b2b15ba97271a6b48a0602c22886cd917ba7f44ee6f2f9234567f3255399bb9c9f691ea87df34fb6221c54cff311b6b6d8b3fc1c04a8a271c0e3eb9bc17c16a099796e2ebe187f81f29568aa7387c6c49d732d78d6b8f9a8fdbba48a233a3220c5c8f6e4a2e0b9a07f600a577e08477402754a63fd90f82346f1f758b866cabbdce9f1c158e6d2b3faece7f5d11c8f6760cd24afa44e0a11aeff01d9a38e7972f61bd60dbcd44aacb22ee414848165a71cf8c5f40015bd83749ab9c488c5d5eb788ace5027454764f78dfc114b75695e0668ebf7208069728e0930edc4c8dbc8c655a0188d94eba7b40f30aae7e69c8a1c0e56eb4824087e6c93e1dd9a1099e4afc589a311fd58b9210c9dd2cfed36d37b1453a47a7dd8e01acf235ca7f701176b514a9e410c5a3373127e6c44c69cf6dde5a86932684ac320b0b6c6c366da135a38d72aa2d733b2a9d94b9133be1acd67d60cbd921999fcecb433adc94ba8c155e420de1bac3dfe0a1ce64fd557e0720f4a9e437ebb80084ebe657d1c1c7df3d22153dc53103d9ebc3165d1e076767089ad0a881b9013bf88341bf6fc78dd9495281f4c34584de0fb6335a0fea0a6ff3357a6b9c91cec2334aeeee5d9dbe2db1bd98c6051d57b4efdf68b8a3c5741b505111ec90c5b74b0b124aab9648d14c9ee478e8b9e2f252941284768747cc69b5ef07732c08ab25e9e9de3b89abea5c1bcb975d104f1c8bd309fac02a7f3368d6e2d7e20f02ccf12d130699dae55cbe5ec05c5e3ae16f8bd1c260b83f1f1497501f583b94da1fbffe96c33239516dd05cac2a23a349f52d6f14b603cf53c1cce23e173e8208fc7961bf77c999e3832a559a7439609ddbd67bb43b5141aa5df25828d04e6ed651489075ba30307220a093a948ebada99d292a0afd9531826ef31751c3b782cc1d55de5c133fa5712a926a12273b2cbe7cd86f1c1088f2a6fbd13323277588d0c9c89e6b2f5de355923753a021afca69fe36ba052a70232b10d3be843678a3b8b5996ffe732b83a51e3b6e0538266927817501f1e4892452d2bdeeee12d4a3e221ebc71cc1962d14792874762fd7e7ea0da235c8886fc801fb6c2de52a01f3741bdcfd314ce7a697b47d56d912d92fd8d18e3250360e8ece3ce15e7e02cff9e63beef364d3c2020cc31272eec00cde1d8337d34ea841e6fa5b5c293bbec94bbd48beebd5075e8d472ace15b160b8cc00ff09e0ee9d744230d7e00823d6c2a2ab24d74f2b18bc470760905714b1c9b396b0368f7f21b766bc4dd469834785238c6e35d19756809aa9c718c66a83a479eb1735afeb220a6cb2285cfadb3b1ab545d5f9abf7455f9a94e7eea52a51722e54c5682ec8304e362f9305647973a439d7f8835a0ec6df043584000da6f7a477e95095f5a1d75fc8c46b60dbef80ea189aa633aff2508e2ccc8a94ec71171ef9f27a86d9848479081a2fd28840b4bf5a4724544658c512fde0ac9dc479a868662f2774667bb2f5827186a1466f8b57bad2c7a775a658d84a3aeb445ffe55dfc4646b7fe218f37dfd7131c127b0262dc5886e53864da32feb765895c873b9347d7d430b683a4cd1687ab97757063d8dada6f68c1772411b4d6de255a34a834a4e654a9966090c911c0229d61fe69fc88eebd4e15f2b74898f439b498d8fb903cf4e61510710964e47cdd2b0a07aa760323d7fe14b0f426759898104700034dd2300f7ee14714d97d49d4e25342dcca5cd2ee9ef43b4776f7b5464080bcd9b06b41e8bc4ae3653477751c69d060f08ca6f3e2f59a04a9eae471c7b8c86510865e5ad78e57db3eea6b28f50fe35c94f223dc4d1a436233b06a872fca9a1b4819f689b29a157183048c34c38e15b9a6ba413076283256cc46ede82bbe1fd9f2da04ef7e726fc7c27699d10df595d0eb31b7fb4dff9f3c1f01047c11791e4456a5104b1f99bef7680e28b475d2087d59cce2288aa091194930d3bbd2abb1569e11c13465c67acecea3975cf8046e79cb6bd9eee3f50a410b1d4d54dd6279a3831f1141e8af2dc95d5a832fbfb5e8bec37d6ebda02566f2b486abed6f8c90d3d5b6fb9ce667f5cdd2a7c7dd8c1e76ed5f98f6c6661928c565b47c4a562dea25e883ccd4fa9cda34c67b4d255f5f0c427c366edfb1587f0dbb1ee0452020ce21784e266c526989751aeaec04535c21f30eee3c7180f18a5e31ec0d46a782247b17387533262827dbb3b9dd445d7006fa634e987ad7749923bc3ebe47d28ad2a732449451a52f3cef84e60893e695c97c62fef2c53a36bb4d6f6b670f6684e4fe74997c954143ac8f20db332d0731aec89b7bc52dc78a6a90aeec2b1142295267288bf982253e14f0989c23ea772f6aaa15a6a11ec9bab2ee80b24295e11209197717033320daf5c227a06eca4969cbfa9dc9c8a0135cde36986d34c72cc389f97da93a470d7e23a70d4bc0f60378269dced4624c209047837d590770827a2260c28d086f904c85214678f5ff74efcf3552adb81b5ee0d7a49c456473cd14ff9343e7928e0567b4f5158354c9d6202d65e138144ba2ac764c08a17848a5820d010e2b2daa63405c2bf2ee813bec9c923a08757702b07b1fc2cf37454776e4b147118c2b18ff4a4fae6f0b133c036b0270b5f311b321a634f828581e9e9dfbdc186b5bcfd44ae70cd64ecfcf18f3e29041365f241d98a7eb6a00d05c69be1bee32e1fc533c2a6ab9842698e096f73f782aa3ee947526d9a9009e76b95519118544c2deb5752105a60414c75e3f3f37858a6c4ebf0e062ba96b648bcd3829e4b2ec83c19551fc29f630fa6e0a47a8442836f0d4cedfc4e7246d5f0b199eb0358fa2a0fbec0e2dc26e9e4f801cd576ca6b7cf1ae4a2cdb3be5f8f717a07651cd75b652e0fb12b2cb06b5c8eb53f7ca7f7f97cf50b717c414dff5ea9f8cc5241fbf5914241c13b7fd42cf37fe4e519c981003d3d5322ee8ca1c81f82ffe8e235b902a24f413fc6bc84da1254d5f269af469a5dd02ae6c4f24035b05b6c4475d715bbb46b2c9718d3168480a6944e59e398c1eef8816043d5169ff8d3bfd86fa526ba6ec244c8879d823ade4ca5c1009eaf0a68e743167e6b8ede9beff4a6b17207bd048fc2285ab93b8dbe516414dfcee452c1dc3663f008d4b52b2d677d6f2320ba432425886464d9f8f17534003a85aa19d0bf7bb78a7ef8f5e3fc400c4c7d4411a8045a6ca0ef910dc2be7177cb65a8e3da72b63d64d6890f3fcd099dd9806fe94ba4407c29febdfd8a5d4398828914b780cbfcc89f96c747f5b3bbfd70880eacb3268aeca3ecafc32938e63fb5fb7d48bbf2c2f288547741faaba0203ed66cb3409fcce638cc6d5a5c54572533e9385dc76b552265692088513e2db1b26af305ed1442b2601dc27933b0fbd1d4850153fd586192683fb29326ab7fff4dc9b47e72585d3e4ea4dc6fd76e4100518df19f5f0bbc4b26fe66027de5cb6559f83bfbd0346760c264dad57732ced9fbf39b972f50a6dd54d3c4c019b08565e93b3adddd3e5ce8ef6816e9c132bfe7945feb31c80c8bea7f9df794b44d83c341d6b32628f1c9c73c331164b16baf70e183c270ef8b8d8f1f33c36c192eb1d5fa3d0d7c0bcb45a366014078977d32dea320a709b6580c6165fb368f4404a854c95ac9fb6535bdf571d6f4f9d62446b731811771d1a3e34154d2e448a94a0e2710fe6029d0f1d2ce48cb966c0da123152a807ca787272273813d76a092cffb57877820d804bfa0602b2079569a4c680dd6381e14dd2862c7a1ea532970ce0cd23bffd3192a52c7293bdc07b46e6c12308e0e19a6e3e91cf203f6c20301368e72a506b5a00e680d3ca12307d1d522c79a7e3969dbf6d30537e2f1fa5c9d867b48c18b9fb2225554acd85ab6133d1500a89b72804b886772209737c6f3f8ddff63ca34b5288769ab63f191026688ed73651792354b959c5675d8377e75a63a1aafbebda5b51e9ab31cbca5fcedebb715df39791c5e2cba6fa82adfd5caa1ca44bd530dac567f69ff939e059c80e02fffcb2d6b86ad5b15b680b20b325574dbb0157cd1dc6686fd7864c37f4ed96b51498dc7cf1447ef8c6954d9773b2b6db00bef961f89aed670a0b1dece618bd4c21091a38ecae0876fc90ef5a33a913365f40bad4bd6ef194b9572df208bd363e96db8611ccb69d5b4bba509ebf8e3282ab5bd7e196d44b79898b8d784e7826499f50cbd7c896c0b7999830c44584c826ec7e590c905c0fad68aa761b63f53f86892d55be19d5fd24826701dbf666b6320ff13ad6dcba11f887da3eb80f27d9bdd27a2babc21094885052d04cbfafd2bf06e8cf56558732504ebc9e928468b7b0887507cbc5e66ffbe4660908ccbebea255c2342233082b10e438bc04a125e1ca488013262ab74f74d78da4aa2f5158adb96a4e94fe11faa7b1c8ab60100fc16aa4ba81fd0d4c9803369e07abea213ce713130f6d32d1fdb1c327a9dc0dfd80aee83660b5e1683878e192a67c2d3714d821d03437389bffd408dda7a34523c0c782294793b85b98f9490230350aaae755d2ab4771465e17249f3fb7c719ca72e1459768f4bf1276b20194b785249477297d9cd0f35ea28fd7ebc11d82aa83b711ef5e81d048a7ab170ccf30d02ebe50f1adb4fe172446a2560e3f47797d9226f9e95be3adebd7e0c9bafaff7bb1a0e00abf1da1642c0d8e01a9c15d8f5e8ab61d635dced2bf65ed464453d26db2fb9293ea33263f5bf9cabafb5b09d66390881f1b5241c5de36c3bb6c4f5c1271f93e6121f207798fcbf6b18d153924bc812fe75d387c43deb13baf50df602c0581b590cd1e213a35ff1a6452f3a2a5deb708e228d9096e7b0d2c1c474386407b306c3cbd08d281f03b00022e66722023a7cad8811ae90e5813c0291b512e23993df5341f1b599e430b815fb7b831046eceb4fa536f72914dc1e8f0fb58c0bebf3c2a9dd4d626b3d9269f300088d3af8b190213c32f563f31fbaf444fb030685c8504a4c22234d08787af3b477e9654c70f570fe0576d77033b52ed0f33bee48bea008ea29f79a8b3a95a7945ed237d403a2491ef8e76132a3a79ebf304b059b61dc4b283b753adba6ec259bb40e3e4cd7cc81e156356bd5b99968546ee6f1c0ce4af72e3df7a7b6152da9c7d48a7b2bdbfd7662ba6650a291eb9fd774e0bda88e2657d54129b1f8e4b6d5d6fd86fc6ef2ffb0c2355a5ae8699c2b3d50f363aa16c6c926c1c06e6ed5918d8614d59372291338eac8325af09e209a80102f7a717af643e9394b7423713e4260d1719a80c41b9626ce9eb472127ca44d60f8f3b05092253e6e46831dacda899bc21de16569df226a25def21c79f51412684e4ac3700c1bd7c674d5cf2a534909b62a55494918dee985a97fa7995511f8fe6c5753fba045e481c7918b1f85ff9617aa93edfd17ec386eede4191ef220eafc08536d0d86eb9f3a2758f1e5bcffcd506875699c781982a94c9f61171c191725cea4cd5b301bc1dacc6f4723075d5fa3fbcbc93c9eeeeb6b5609eea15c2e1a9ee51e763ccfe0cf6287affe2089fbd3409054fe5026df9dbaf368624a7cbc00c36c029a8dcdae5b09428a69ebab676dc8accc96c847a0de7e21d1abbdee6b01f2235df48513f840dbebf8b3a9ea6ee93c5cb1d5cc963000a6529fff3c86a710273b9822d8d1b52aa9c8fdb76b83d65f81a86c2d179e972474df9272058631e0c7bf552b28e2637c67880b133ea8497abd13dde68a6a95acd53604552e1a41a5e06aaf46df94d371a0f71e0965a87783f1d1833f946a100aeabffeb00087293df9520af230a75e3c8a3507155265dafc99af13911502716ee2ab339feeabe0bda82d446bd264cb35e27a145e7868b94358707268eeddbb187f50a8158ba5ccf216e32719bad8966968139f60233f9514a0f1a55751699283557ecb1f444cc7a8389354ba3b5b7ea05c169bb0680caffaefff0995650603382c8b2312e7a2229469a7c5f4c212a314ff1c21d99a802da22db2e37d063f7287b6273931a77597b90527f914d64e7a8bbded768479a25f37d4713337e14c5cd58c3d5a172723a95ff358c73220d9ba23b415beeb7c44e51108882cb27b1ae362d589266faa1909e2a2906fce1d4ddb987f4710ad35fe9dac6b5a82928f8124ca33ea21ea542a3aa0037a5114a6029312a9b23375e763d8c0ad3e44a0ab61bce1e421a76283ca67305e817612ab1900fad627e7120ed6131fbfa928d53babede716a22ca769ba206ec93431f44a7a36de83b9bf3c02d4adf759a874192a542d90faae88853f5dbefb3ea06bf0f68e83a51c990528f5a519c75101995e6300b8f64e33bf094ab64be8f84ad9b1be13614886dd6b73735875314f4151e6f90202f3d554f2c0316f1c0f3d328ba39732adb700e28728aa208399be279c73a403b94d1b6421bc765eb18b08dea783c4b426403af868fa342c21a2fd5ef52ff06ddc5901c97c86f1232eecbea0f253acad3868f7d6f76a32420c9d7e69214a8f590517ea25c2109f9495cabf087ad480b91de6a5c4c349786dcfd249a891f001aed5fdf6b2fc3b52679b0cf4368873646db72addd776c29d2061065afdd0fbf02c47c4c9fe93e06192a12dcfcdcdb1ed5e493f6686cd02e4d351c03a506eaba368bdc0fc63a4e27bd635979f7c0e1fd618507f77031f520b1b6487ce03915b8da211e987117c7d68d0202d7adb420d4406492c6eeb3a4051a949f18a39af8df8e7282dac1d612e9d75f76916a50e368ae633ae6c351ec99cf6934d7f475d523c3b23342542ef6bbc7ac356ba65cc5a34d7585bf2117ec66f46a5a29ec64fa328443978c91b44a657c8c465db0b0d89183b520b3bb5fba3a1643a2d75ab7a2ca783e90a89a72409ab150cd3ec6cf99612e9bcf44eff5ac786bd5796941650cef39a4aa892e4d820e29f14852f4dee51856d9487d224dc84e63e990e1b2a4a43b69771923cf9afe06d8a836d883148c9b409947f8ee82545f5a8a2562a47a2759d50b4a3e355b2de49ab83239b31d1741494bee9a053855f2b9e5c836ae0051fa132bff3312712395e216b8976f47234efda974bedaf60a1ec3f28581d69bc29ee74430f9e5b0699c0faf9a171fe2b7edfb581efbca0ccc8909a9d14a95a6e8b15e57c64ee64a0215b399ec012ddc4735d1bb2fd03e5c07c36d7c802d776fabd76675d9c92bfe8cb71a11db7ae73ec38df22f6b3a243251a9548cac8846215bf6c905df88166557e79f9a13004f14bb800c1b2a31962207eebad43135f3ec9281162317e76e242f796a4a288a43df21d351b07c4bab7aa2c0b0a9903bbfbbc465f3f416e0f56b737e52d610730ae197210b7aa884bf1d02672f93a94cc36d05dc30150f3bb74c57b7faf4f3e7be22f9d47a9b8c9f319f721f891f3f13af11669365ac2a09024be53646b20e9dc388e0ebe6df4b7e313378be2d1249d291e2f0c9d9dfd79cfb44be01ce34934a0bcc8d994ab2f1eeffdc4a9854fa42b0dd60bec42dbbee0bc9ac1e5792e6823530899194e96d0483c8b86bf07841fe29b0e48d098cb7f80c270db13c6dbdfc4162e00b43dfe782c0da6820ba95ac1f36e4d988c708cd3694ac6b2d96f88c54c04a9a925931cd4b031aa9e5462dc67e1817ffbeb4640fe643a99618da85c403c5bc07552084676cd3c5be81ff6106dc43b0c1a225d666bc7ea18087c7bcf3e786f32125ba757765a069cc13961b3d253194e43eac712a3c38a80fe36280d81fbeb149dadf10f9c87a3bd2f42ddb15975f20812f4b990403f465783f9f14b5538b32b67bb5e76329935ab58c5578d99ee6f1682397620d5f102d0f29805fed3d6000a2a4ec444d0c92448a94eafaaa6a7c38a5deb512feb6bb3879b8df20da92995be08197b504bbe0116c5179a0d7be71732d54e10ca730a28b42cef27afa173e5bde767df6492fbdc96a72f5eed493cfc14fbbba98924e54a0d0cf34741cddfc101b5fc398f9449f70862b9335f3b1405b53c3ce17fcce06fd4da38b55066d2e0c56e50808f150b9ef25675d6f8fccc0b8563c8ee011df144d47d946fd77488d97d14cb881073630a16e7d9a5af6d9025f87babd0fbf09e513f4fd7b2d8764c32b5e5ea531ba74637cebb4dda3420f2d4db6174a7086d09cbe573fd8e3f70e3cc4c9ae00113de24d54b758aa0027c307fa140c90453d99927c65762b2d10a527823cd4886199e14dd7242110e93084ffed86278739b20204fa184cde03858eea2c66b128058d3bd75483181d0b2ac9bd72de603dc45182ab5ffdbabdc81f3c37d9227965b90f929645c4e082abaff1eea28d6cd4be0bdf89e6f1a5ab22ba2e52c81badd37ad62aae69e9e936daf27c43a9b9833bcfc6603c1bb3bfaa4d3031817778fe306e69221cad783dc56050cee20b79efc3373ff4842849e76ad5d8f8f613e575b29ca435da56f28b33416e886bedbdafb77a8fd8b90fef5fa83fe9af79bfe2e466e9d74c18d2b6de907582f2f252be2132734306518d948835da1007425a0d2170b103bf7ac1b1c247dc1efef64f01295d6d2858ecf8bc14f329a0b46eb807bc804fad327adabc6f158f72fa88c5a40b547badbe43001e72d6da793a9787d5e32235870bd34189a60e825d71e36196a5118cebaf667447e3afac8ec713cbab96c8cdd3e62ab65aa5692e9a7965a0bf40c6e20c378630d826142d893ac92e234d3b27006ec409a70d691965a514143a7331a9fc25c736380d233fd29ecf4d694c336bc571b234f922f737524577621c47a18f8e21cbbd85b9e507e3d150e827f7b812ec72e72a049dae74aa5fbee5a201f80ada2a61ca02ea35a5ab8ddd9c6b4b77be0877bac0551b7f79ff0e500cf9dc2ae6f00f2f9838ba93e8a8480f734fcd2ad46cf5cb4ac82e07181cc76ffae85ac7bde2a25d58e2cab05caa568778b3253fa5d51fbf2ad533faa06b82d9d9a76b481b2d33c3a22827b999e14682faee2588897df29f80490b64bb1e050c3da08212594adc637d9ac81aabad09eadc0acd828b778452b2325d392baf835e80f00df48d1df54dd47923b9936b6714c98feb6a4feeab2577b5690b3b9e564939ae25dec301e9d4351fc53ce90e63ac015002ff9c365ac6798f498a6837675935b9da79d3db0aa53c2afe0351aa5f7c29c9f19a531564e0329affbaf18ab16af5411fdb3ce0005a350057039d5c8f1b83c2f3efd87b6abb001dc71ae35b2569826c208ea2bef4c2eb38a0f7dde56e01de16a7e074cc691b54d93652c671502332e28c2c1981bab493d61ca2b0668acff4a5ad93e3d35cc8117441cf882679e15872b4cc893a58e202c7237db838191c37729d81d9249da75159042c981949f84dc5d3739c49785acc1c405e2dd3e71ec1ffef07461f3a4c1a16aaba877e690c35f95c3e86fc600494565e28428bd655e854d1484333fa02e343bc2808edd59d897a1bf57fd46327b936f53b8c6f27a58163e10dc3bbdaf852d8952be5907adc805eef8e472227ec7af07a1cc639ead722ec2088eac700e09419fa51e4543ceb6a6541f7f6a5c54a48d3ec607dbf4f351d03c326ebebf34f0f82aa041c7dcff5b296116d3d5e8781d345d085b631a52405beecc48706fa5413baf8f1309036d9cfa86d3a17f31d2b284278bfa83dfd44a7cb1222313fe24636ce27bca8a88e19a08483eb40910dcad53c992ad837a3a6cc1db925a9678c19793bc57932c4c0eae801ffbd2c6bb4d5c333a28ab756ac6d722de7023105eca919146f3c305dcb0191e196cf1eeee65eee8845d54b21b28b9d11d28d5a7f17c7c0b6d6f7ff4eee837afc79170385aa7d9c3701149093459743ca965d79e83c72f208c19b5db06dee3f8ff69cfe70e5d2ed8e8fb3459e4ce9f8d921a53475a4217ed15f8227094cb66e01f8226a131c5a9c887c7865f9e861f63838d93112653da3f62f0fbd4f2f7c79addc3e9d0499407d44810cf2743e328c58bf5e45b3421b262a9de23fcf2a4056bb72da010a0bdb0cc7ca60911466e930157a3bc4a321115fe696a6294159a28b5e903a9e4f6ed58edd0123213fba5c7781849cd2f3dcea62346cb642593cca128a8ad874c24b555d2689dcd854a1ba7f0099783d7e4e907c03cb8b1c65cfa6a2730047d9df67ff7d109d5d4c47d725359143d3c97084633956db8f131c9b023396103e61ff01aa9d85790ef0e8904fb924c11c1683c67d6073292c4872afa3f394c3037a930cd363a51ec09698473709effdc2208ac595aaf099dcda66fdc343517814b00bed32a6f0be54f9f5694fee40537fd8c36f7e1905cb5251c00d70dc145c66fec8dc242ed0e41df4a3ab4319128907fae289fe550a232d97c862b4a15bd3dc5069bb72e61df114c5d985257f396eb9e44d05c8d43d8cdc12115a893c4c420780121576e4d1cef9ae794fab93a4061c612813b936fda4d043458e3ac6804323bf3889ea9616513de4a18940c153beae4b039b3e2c0cce83fb3c9865194b2563bcd81c004cebd30912db5cdfc66ef15a87bd93ac0ef8423bee6c463c159ca764a119849b0a8ada3756442ecca7cb0b02573ecfa9daa3673fb61b2c9f6fa8f7c883dcbb969a243b9cb366cebf5008cb7392d21c04cf25799b2ae95ea80bba52439380488b252d4e7ecb7d8d3db0c5a8179aba2adfb3f1cad18f6697c9964b874bb9f6ab565226e1bd922ac3a90a5959bb3417be6937692fd919fdb2146ccfcc2f574dcdab6d92709d5068e452272d2537ac43ae5cc79fecdac7cd03544ed74104d190f7c6d86ace76197d91e32f61a89f28ce8fa70303410fd67012d64a6366941984ce957bbaeb36d0122a4b01298f48d53607fbaef82cc159008157e9fa695df9e49d9d0f636e8fe4abd403787dd247ff62ea59c5875247a7d3dbdad0481b5aa320cd3f23b2b8e4ae01ee2f733af056d1e8e924232ac5800932f62fba6db3eb089acf452b2f511078c892ba65f4e5eecfbd40686c585cd4ac8c20cdc00c0a055160cd2edca6e61024fa49c0a0b2fc935b3d0964ae670f8fe76413a96023dc0d015b240c0a1801387c9127d37df06c9ba955d6b47e81832a5b16d3c77a4caee21465abac9f0951ae26f8ea3f2de76a4e2f6deb80e7b0dd04614c3366d1f1c2acbd4a0b9fe0f40f56df11f51b74a77c13cd56aec857fbe983bec2d8603eb726161c11085dfa511008fb16139bb358278f549ffcf93af77af045b6b0306d8acc36ad5932450b09fe894ada05da2dbc99e64ead2e52b5d155a638e35bd5ca8b8fde7add5c6b8bf53165e676e7d8c90bd586cbeb5d65f3a2cd86da95b7a3c7655ae663265f2dda02ec284a5db3f3dadcedcc32db86d4ef220b96301a0827e30639e4b2a7c22ba91a57fe2e7df225200c83df8e74c4903b6e0fb812b02994648f0cb9a102e5f43e9b79271ea103d62c4ec22adb7dbd3f29be7a93285b44d1b79a9b980513103e07147f02c64b26dc94f0bcaaebbc0242b574130a28e244ac58498cb3be9a408ba5e8fe82ec4e410428a8323c1f1f1311b0665244480749ac8bd00b1be4add12ec854bcd60bb98c6a2cc858579ac6957a3af0682caf02da22348436b707db5c5315a330d5c2669521c8af41ac55982113c8cce181965634e234d4d4a90f81bf50ac12def3a61a3ca0c8c2446bbdf50f96fc610aadb4cf39ef06042996e8e96f20acd5938c04ca13338ecdcb35c024933526b870308bb54fbd16adb3de635f1862336b50d0b955428927f6094ea37ed0f7b630d0f94c3559bddfef4e602eef8634b95581a5a4046ef2bbd42ff40ecffe10751c1ed6d364f7981e1dde9c368e11215b014cfd3d4096c0c3604c3d37bac93e690a94c226678a721bca4fa16981e1d570f19e638030988fd2a3c5b47b1cb838f2fd1ab474db7f359265a54db8ea70bdb065124e11f6d62caf5065b7f3fe54758986d774616bf62440c5ae8ed01c7c2e5a7b863661e3f492ca1df81287d1c353079c55e83f01b9a16973641f0ae992c2149edaad663218f5ba44c15113176c4f9efb3754015880988bcfafa040d6f4e5d38569cd0e5cc2c405fd47bcf695f5ef06c8fb84ee6b4ef943855b7854882e780a7da74091c64cbe9d821265d90577211b9d4c0ed3eaf04da94c7ba8d5d628a40cc1170ca836e326ef9fe9ec4b9473b6a36cda1d5b28843bfee12bc06f6406c13d15ffe454684afd83c13e1a61ffcbe22115afbaca44b1b4a590664093e21cb55ccf1621e00b252a41c828518054a6f67e7a19007f767d545ca3479cec6e5c76fec8b67368b6d5d14266d123fc33d0eca8d0413064f257f783895700afe0a29e9400616f51ed08e3c7a9590615eb1745367b2052797049b19deb7dbdcd280b14142c8f8734486cf0bef7bd1b4b70785b7ee67ba2294146b2f88bcd886c6f5fef9a6c2f3b4f7b3b03c875f0889aca97be5847b73b5d51fec67cdcee642a12d01c99a8f9034aded24c88ae78f5785125f8de1739e6bc1c788d9018a32df198c4959fe211d52130c428662082415a6983052bf278ce3438707e0c48c6f49765e60c56a14ebb7cbd18d9d973aceff68c65db258337ff16b9311d6c4fa66ccc2ff2be800fbd0892aa8527a30138ddbb4f64df1633a5e8eb18c1d1606c34b5165038e1e803872e1653777f42f03b363328b2cad4c5c3110a2e89ba2a8ec67ab8a3e02c4623d3302c553a8a8d8a2656e803a08f82300cb95fb563e4e8c8123a31e361718f230f8310e650665978fe81a288db37e6ffa7a77e09bc8f8a4beb4c55cdcf4fa22b4cfcf4d46619d18af1e4448bff7c688c25c13b61ef7480dba5ead7d56a9543f203dc2b401512fc37a8b9ee76e4e70de06a66ba240f4b021f2f5d86e58b3d1eb6680a63619ce724b80f14547b02f4240eb29a56e7061ccec9d6476bb976ac0883c9836c4d55a05008c55c5a09f349efc2852d49fcab687356fb792faea2a0e5174be6de5d72be2c639ddc7128fbe3fa6e30f6164dd0fba16853968db95688c888d9bfd25f5691599150fef3fa081bd184933d9009820ed7d51323511c39ae5a2ebe74484661d33c2e15ba4ea17f68801f2ee78cdb8a327d6028919c220180eac285a8bbcf0f826ae1ee612058d7572a3c274fd83b92b0d68a1de824289cb8e402040d4556cb1b89070db24c1cd6f1f71ceb20278b0755e5073394181993f8d4d611292cb4df6963d002af0f8232cb95261e347d6c8e07fa19170748bfac62a454744a0fcc0b0245160532f91ce22042502996c11071685e408e9c7269eaae54171e6245ef5cf5333703344cefafa30f692090f0f6387cafadfec566362bc7236100c3eb832088ccf6202847cd561fafd654b7c89c624f6511ccc2d7402364686f3f82147aac2161358ea1b275216c01e55c178decce6e5b21e45885134e4b3b2f41756b503e56e87905f9e474a3b1ddae9443d5e1f0c1e3d4830e9e1e5cb5ccb0f543a0d888954745fb409bd673f52f21344a16f2c0cff0a10e4d08ae9998af12168fe6679e2a0135d5c27f9de7a5499ef51c9cc71a18748d66ffa3644f8a50ac980c2e9a75a9cd0d468f4a4eccda6ccdbef0b4346dd878f27ae01939c36c8a1e19b45763162ee1a174cfcb9dfe385533b1c06ef19fb16d1e123d7756ba0de4665fc0ea6486faef08040ee7a5d5a868109f62f7eb2074f9abcba8aebe512938c27de2fc17de8f509e2289b8792dc01768e3ab18f2453fe92fe2ff6568a623361612c754bb13f8df5f0a52d7547c56fa9c4fa28240593bc7633a7692a4fe3c3bc063ebf355931ce1c9af438ff275565dfd8becf049eeaaab31c4f242b04290d5f0dce4161f51340a910bb751056679791a5d5d64dd2eb471573b02274839e0bd8971390aa153a52801b0dd68b447968b63b2b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>私密</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>利用shell解决的一些问题</title>
    <url>/2024/05/02/%E5%88%A9%E7%94%A8shell%E8%A7%A3%E5%86%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-在-tmp-下新建一个名为-missing-的文件夹">1.在 /tmp 下新建一个名为 missing 的文件夹</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ~/tmp<br>mkdir missing<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="2-用-touch-在-missing-文件夹中新建一个叫-semester-的文件">2.用 touch 在 missing 文件夹中新建一个叫 semester 的文件</h2>
<p>首先学习了一下touch的用法</p>
<p>作用：修改文件或者目录的时间属性，包括存取时间和更改时间。如果文件不存在，就建立一个新的文件</p>
<p>语法：<code>touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</code></p>
<p>参数说明：</p>
<ul>
<li>a 改变档案的读取时间记录。</li>
<li>m 改变档案的修改时间记录.</li>
<li>c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。</li>
<li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li>
<li>r 使用参考档的时间记录，与 --file 的效果一样。</li>
<li>d 设定时间与日期，可以使用各种不同的格式。</li>
<li>t 设定档案的时间记录，格式与 date 指令相同。</li>
<li>–no-create 不会建立新档案。</li>
<li>–help 列出指令格式。</li>
<li>–version 列出版本讯息。</li>
</ul>
<p>实例与运行效果：</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>运行效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>touch testfile</td>
<td>修改文件&quot;testfile&quot;的时间属性为当前系统时间</td>
</tr>
<tr>
<td>touch file</td>
<td>使用指令&quot;touch&quot;时，如果指定的文件不存在，则将创建一个新的空白文件</td>
</tr>
</tbody>
</table>
<p>可以用<code>ls -l</code>来查看时间属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd missing<br>touch semester<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="3-将以下内容一行一行地写入-semester-文件：">3.将以下内容一行一行地写入 semester 文件：</h2>
<p><code>#!/bin/sh</code></p>
<p><code>curl --head --silent https://missing.csail.mit.edu</code></p>
<p>这个题涉及到转义的问题，如果直接用双引号的话，!在双引号中也有特殊含义，下面详细讲一下shell中的转义问题。</p>
<p>shell中的转义有三种途径：<code>\</code> <code>''</code> 与 <code>&quot;&quot;</code></p>
<h4 id="三种转义方法的使用范围">三种转义方法的使用范围</h4>
<h5 id="1">1.<code>\</code></h5>
<p><code>\</code>的范围是最广的,几乎可以对所有的特殊字符进行转义</p>
<h5 id="2">2.<code>'</code></h5>
<p><code>'</code>将会对其所包含的内容不加修饰，转义出来的内容就是所包含的内容,一个字符也不会改变</p>
<h5 id="3">3.’&quot;’</h5>
<p><code>&quot;</code>的使用范围比<code>'</code>小，<code>&quot;</code>会先将所包含的内容在shell中运行之后再进行输出</p>
<p>例如&quot;tell me the date&quot;:这段字符中的date将会被shell运行，替换为当时的日期</p>
<p>此外，shell中的特殊字符都会保留有特殊含义，再显示之前都会对其评估</p>
<p>经以上总结，我们可以简单的写出这题的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo &#x27;#!/bin/sh<br> curl --head --silent https://missing.csail.mit.edu&#x27; &gt; semester.txt<br></code></pre></td></tr></table></figure>
<h2 id="4-使用-chmod-命令改变权限-使-semester-能够成功执行">4. 使用 chmod 命令改变权限，使 ./semester 能够成功执行</h2>
<p>在我们直接在命令行输入<code>.\semester</code>时,我们会得到<code>Permission denied</code>,这是由于权限不够。</p>
<p>在输入<code>ls -l</code>之后，我们得到<code>rw-r--r--</code>,发现没有搜索的权限，所以我们无法运行程序，这时我们需要<code>chmod</code>命令来改变权限</p>
<p><code>chmod</code></p>
<p>作用：控制用户对文件的权限的命令</p>
<p>语法：<code>chmod [-cfvR] [--help] [--version] mode file...</code></p>
<p>参数说明：</p>
<ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是</li>
<li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行</li>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<p><img src="/picture/rwx.jpg" alt="示例"></p>
<p>如上面的图片，该变权限实际上就是改变指定区域的字符，改变方式有八进制方式与符号模式。</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>chmod ugo+r file1.txt</td>
<td>将文件 file1.txt 设为所有人皆可读取</td>
</tr>
<tr>
<td>chmod a+r file1.txt</td>
<td>将文件 file1.txt 设为所有人皆可读取</td>
</tr>
<tr>
<td>chmod -R a+r *</td>
<td>将目前目录下的所有文件与子目录皆设为任何人可读取</td>
</tr>
<tr>
<td>chmod 777 file</td>
<td>将该目录对与所有对象的权限都设为rwx</td>
</tr>
</tbody>
</table>
<p>所以解决这一题我们用如下的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">chmod u+x ./semester # 让文件所有者有搜索的权限<br>./semester # 运行程序<br></code></pre></td></tr></table></figure>
<p>下面解释一下运行代码中第一行的<code>#!/bin/sh</code></p>
<p><code>#!</code>被称为Shebang(Hashbang),在文件中存在Shebang的情况下，类Unix操作系统的程序加载器会分析Shebang后的内容，将这些内容作为解释器指令，并调用该指令，并将载有Shebang的文件路径作为该解释器的参数。</p>
<p>所以在这里相当于这句话的作用是调用/bin/sh程序来执行下面的代码</p>
<h2 id="5-使用-和-将-semester-文件输出的最后更改日期信息-写入主目录下的-last-modified-txt-的文件中">5. 使用 | 和 &gt; ，将 semester 文件输出的最后更改日期信息，写入主目录下的 last-modified.txt 的文件中</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./semester | grep last-modified &gt; ~/last-modified.txt<br></code></pre></td></tr></table></figure>
<p>借助将管道的输出信息输出给<code>grep</code>,然后<code>grep</code>查找输出中以<code>last-modified</code>开头的信息，然后重定向输出到主文件夹的<code>last-modified.txt</code>中</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>基础工具</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构</title>
    <url>/2024/05/01/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/2024/04/28/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="快排">快排</h2>
<p>时间复杂度为O(nlogn)</p>
<p>算法概述：快排排序算法的核心是分治算法，往细一点讲就是：指定一个中间值，对序列进行划分，左部分全部小于该中间值，右部分全部大于中间值</p>
<p>之后再对所划分成的两个部分再进行划分（递归处理），最后达成排序的效果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid=a[l+r&gt;&gt;<span class="hljs-number">1</span>],le=l<span class="hljs-number">-1</span>,re=r+<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(le&lt;re)<br>    &#123;<br>        <span class="hljs-keyword">do</span> le++; <span class="hljs-keyword">while</span>(a[le]&lt;mid);<br>        <span class="hljs-keyword">do</span> ri--; <span class="hljs-keyword">while</span>(a[ri]&gt;mid);<br>        <span class="hljs-keyword">if</span>(le&lt;ri)<span class="hljs-built_in">swap</span>(a[le],a[ri]);<br>    &#125;<br>    <br>    <span class="hljs-built_in">quick_sort</span>(l,re);<br>    <span class="hljs-built_in">quick_sort</span>(re+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可能会有人对以下递归中的参数有所疑问</p>
<p><code>quick_sort(l,re); quick_sort(re+1,r);</code></p>
<p>re指向的是从右到左的第一个小于mid的数，相当于要对从l到re进行排序，从re+1到r进行排序,这样解释是不是容易懂一些了呢？</p>
<hr>
<h2 id="归并排序">归并排序</h2>
<p>时间复杂度:O(nlogn)</p>
<p>分治的思想，及将序列分成两个部分，将这两个部分分别排序,之后合并为一个序列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],l,r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归结束条件</span><br>    <br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>,le=l,ri=mid+<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-built_in">merge_sort</span>(a,l,mid);<span class="hljs-built_in">merge_sort</span>(a,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//分别排序</span><br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt;c;<span class="hljs-comment">//用于暂存合并后的排序好的数组</span><br>    <br>    <span class="hljs-keyword">while</span>(le&lt;ri)<span class="hljs-comment">//合并数组</span><br>        <span class="hljs-keyword">if</span>(a[le]&lt;=a[ri])c.<span class="hljs-built_in">push_back</span>(a[le++]);<br>        <span class="hljs-keyword">else</span> c.<span class="hljs-built_in">push_back</span>(a[ri++]);<br>    <br>    <span class="hljs-comment">//可能会出现一边没有填入vector完的情况</span><br>    <span class="hljs-keyword">while</span>(le&lt;=mid)c.<span class="hljs-built_in">push_back</span>(a[le++]);<br>    <span class="hljs-keyword">while</span>(ri&lt;=r)c.<span class="hljs-built_in">push_back</span>(a[ri++]);<br>    <br>    <span class="hljs-comment">//将暂存的数据填入原来的数组中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,k=<span class="hljs-number">0</span>;i&lt;=r;i++,k++)a[i]=c[k];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实在算法题中直接调用sort函数就行了(在数组比较短的时候是插入排序，数组比较长的时候是快排)，了解以上两种排序算法其实是加深对分治的理解，除了这几种排序算法外还有冒泡排序、选择排序等算法。</p>
<p>排序算法能够做到的最好的时间复杂度就是O(nlogn)了。</p>
<hr>
<h2 id="二分">二分</h2>
<p>此模板不用考虑mid+1或mid-1的情况,比Y总的模板好用qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> l=<span class="hljs-number">-1</span>,r=n;<span class="hljs-comment">//n为数组长度,数组从0开始存储时这样初始化</span><br><span class="hljs-keyword">while</span>(l+<span class="hljs-number">1</span>!=r)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>())l=mid;<br>    <span class="hljs-keyword">else</span> r=mid;<br>&#125;<span class="hljs-comment">//最后根据实际情况选取l或者r作为结果</span><br></code></pre></td></tr></table></figure>
<h4 id="下面详细讲一下这串代码">下面详细讲一下这串代码:</h4>
<h5 id="为什么l的初始值为-1-r的初始值为n">为什么L的初始值为-1，R的初始值为N?</h5>
<p>这样赋值可以保证数组不会越界</p>
<h5 id="为什么循环结束的条件是while-l-1-r">为什么循环结束的条件是while(L+1!=R)?</h5>
<p>之前学过二分的小伙伴可能会发现，之前学的二分，他循环结束的条件是while(L&lt;R)</p>
<p>而这边给出的循环条件是while(L+1!=R) 其实，就是当L和R相邻的时候，循环就结束，而原本的while(L&lt;R)</p>
<p>是当两区间重合以后，循环才结束，所以之前我们需要判断对mid进行加一或者减一的操作，而且因为区间重合的问题，最后返回的L、R还要再进行判断，而这边的这个二分，因为区间反回的是不重合的两区间，只有L=mid和R=mid这两种情况，最后根据需要返回L或者R；</p>
<h5 id="为什么不会陷入死循环">为什么不会陷入死循环?</h5>
<p>对于比较奇葩的情况，比如数组大小为1或者2</p>
<p>比如int a[1],b[2];</p>
<p>由于我们是while(L+1!=R)结束循环，也就是当L和R相邻的时候结束条件</p>
<p>对于a[1],他的下标为0 此时L=-1，R=n也就是1</p>
<p>对于b[2],他的下标为0,1 此时L=-1，R=n也就是2</p>
<p>所以无论何种情况，初始的L+1始终小于R，历经循环后最终L和R相邻，不会出现一开始L就和R重合等情况导致出现while(L+1!=R)循环不能结束的情况</p>
<hr>
<h2 id="前缀和">前缀和</h2>
<p>前缀和算法适用于要经常取出数组中某一段的和的时候，能够将O(n)的取和操作优化为O(1)<br>
就像它的名字一样，前缀和就是从数组开头一直到某个序号处的所有元素的和。</p>
<h2 id="code-3"><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//假如有数组a[n+1],元素个数为n,从a[1]开始记录数据</span><br><span class="hljs-type">int</span> head_sum[n];<br>head_sum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)head_sum[i]=head_sum[i<span class="hljs-number">-1</span>]+a[i];<br></code></pre></td></tr></table></figure></h2>
<h2 id="差分">差分</h2>
<p>差分数组可以说是取前缀的逆运算，差分数组的前缀和数组为原数组，差分用于对某一段连续的区间进行加减操作</p>
<h2 id="code-4"><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sub[n];<br>sub[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)sub[i]=a[i]-a[i<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure></h2>
<h2 id="双指针">双指针</h2>
<p>双指针在多数情况下为左右指针与快慢指针的应用，当然也有一些情况需要灵活运用，下面举两个具体的例子，分别是左右指针与快慢指针的。</p>
<h4 id="左右指针">左右指针</h4>
<p>题目:输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>显然，这题用暴力做法的时间复杂度为O(n^2),但是如果我们用双指针就大不一样了(O(n))，见如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//假定一定存在这样的一对数的和为s,假设我们已知数组的长度为n,且从1开始存储数据</span><br><span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=n,res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br>    <span class="hljs-keyword">while</span>(a[l]+a[r]&gt;s &amp;&amp; l&lt;r)r--;<br>    <span class="hljs-keyword">if</span>(a[l]+a[r]==s)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,a[l],a[r]);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    l++;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解释一下上面的代码中的为什么可以直接<code>l++;</code>,而不用重置r:</p>
<p>当右指针扫描至a[l]+a[r]&lt;s的位置时,满足a[l]+a[s+1]&gt;s,这时将l指针向右移动,由于a[l+1]&gt;a[l],所以此时a[l]+a[r+1]&gt;s,所以r保持不变，继续向前遍历是合理的。</p>
<h4 id="快慢指针">快慢指针</h4>
<p>举个简单的例子：输出链表中间位置的值.</p>
<p>何为快指针？何为慢指针？简单一点理解，走的快的为快指针，走的慢的为慢指针。</p>
<p>例如在这题中，我们将快指针与慢指针都初始化为头指针，然后画快指针一次向后移动两步，慢指针一次向后移动1步，这样，在快指针到达终点的时候，满指针恰好到达中间的位置。</p>
<p>由于过于简单，此处不用代码加以说明。</p>
<hr>
<h4 id="离散化">离散化</h4>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学（上）期末复习</title>
    <url>/2024/05/07/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%8A%EF%BC%89%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="思维导图持续更新中">思维导图持续更新中…</h2>
<p><a href="https://gitmind.cn/app/docs/m3jtdt2i">离散数学（上）</a></p>
<p>点击以上链接😉</p>
]]></content>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>第33次CCF认证题解</title>
    <url>/2024/05/09/%E7%AC%AC33%E6%AC%A1CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1-词频统计">1.词频统计</h2>
<p>简单题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> cnt[N];<span class="hljs-comment">//记录每个单词出现的次数</span><br><span class="hljs-type">int</span> cn[N];<span class="hljs-comment">//记录每个单词所出现的文章的个数</span><br><span class="hljs-type">int</span> flag[N]; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-type">int</span> count1,num;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<br>		cin&gt;&gt;count1;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=count1;j++)<br>		&#123;<br>			cin&gt;&gt;num;<br>			<span class="hljs-keyword">if</span>(!flag[num])<br>			&#123;<br>				cn[num]++;<br>				flag[num]=<span class="hljs-number">1</span>; <br>			&#125;<br>			cnt[num]++;<br>		&#125;<br>		<span class="hljs-built_in">memset</span>(flag,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(flag));<br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>	&#123;<br>		cout&lt;&lt;cn[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="相似度计算">相似度计算</h2>
<p>直接开set,没什么好说的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> cn,cnt;<span class="hljs-comment">//cn记录交集的单词数,cnt记录并集的单词数</span><br><span class="hljs-type">int</span> n,m; <br>string word1[N],word2[N];<br>set&lt;string&gt;bin,jiao,words1,words2;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<br>		cin&gt;&gt;word1[i];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;word1[i].<span class="hljs-built_in">length</span>();j++)<br>		&#123;<br>			<span class="hljs-keyword">if</span>(word1[i][j]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;word1[i][j]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)<br>			&#123;<br>				word1[i][j]=word1[i][j]-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>;<br>			&#125;<br>		&#125;<br>		bin.<span class="hljs-built_in">insert</span>(word1[i]);<br>		words1.<span class="hljs-built_in">insert</span>(word1[i]);<br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>	&#123;<br>		cin&gt;&gt;word2[i];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;word2[i].<span class="hljs-built_in">length</span>();j++)<br>		&#123;<br>			<span class="hljs-keyword">if</span>(word2[i][j]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;word2[i][j]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)<br>			&#123;<br>				word2[i][j]=word2[i][j]-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>;<br>			&#125;<br>		&#125;<br>		bin.<span class="hljs-built_in">insert</span>(word2[i]);<br>		words2.<span class="hljs-built_in">insert</span>(word2[i]);<br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(set&lt;string&gt;::iterator it=words2.<span class="hljs-built_in">begin</span>();it!=words2.<span class="hljs-built_in">end</span>();it++)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(words1.<span class="hljs-built_in">find</span>(*it)!=words1.<span class="hljs-built_in">end</span>())cn++;<br>	&#125;<br>	<br>	cout&lt;&lt;cn&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>&lt;&lt;bin.<span class="hljs-built_in">size</span>();<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="3-化学方程式配平">3.化学方程式配平</h2>
<p>根据题意写代码就行了，这么简单的题我当时居然没拿100分，有点气人</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bit/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gauss</span><span class="hljs-params">(<span class="hljs-type">double</span> a[][<span class="hljs-number">50</span>], <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> hang, <span class="hljs-type">int</span> lie)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt;= hang || y &gt;= lie)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 用于判断第一列是否为空</span><br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于标记找到的第一个元素不为0的行号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt; hang; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i][y] != <span class="hljs-number">0</span>)<br>        &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            idx = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">true</span>)<br>        <span class="hljs-built_in">gauss</span>(a, x, y + <span class="hljs-number">1</span>, hang, lie);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//idx不为0时，需要将这一行与第一行换位置</span><br>        <span class="hljs-keyword">if</span> (idx != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lie; i++)<br>                <span class="hljs-built_in">swap</span>(a[idx][i], a[x][i]);<br>        &#125;<br>        <span class="hljs-comment">//对下面行中所有第一项不为0的行进行减操作</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = idx + <span class="hljs-number">1</span>; i &lt; hang; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = y+<span class="hljs-number">1</span>; j &lt; lie; j++)<br>                a[i][j] -= a[i][y] / a[x][y] * a[x][j];<br>            a[i][y] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">gauss</span>(a, x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>, hang, lie);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> a[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>], cnt, q, k = <span class="hljs-number">0</span>, N = <span class="hljs-number">0</span>, flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//二维数组a模拟矩阵</span><br>    string thing;<span class="hljs-comment">//存储每一个方程式</span><br>    set &lt;string&gt; s;<span class="hljs-comment">//存储出现过的元素，并对其去重</span><br>    map&lt;string, <span class="hljs-type">int</span>&gt; b;<span class="hljs-comment">//存储某个物质中某个元素所对应的序号，即在矩阵中的行数</span><br><br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));<br><br>    cin &gt;&gt; cnt;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)<span class="hljs-comment">//创建矩阵</span><br>    &#123;<br>        cin &gt;&gt; thing;<br>        q = <span class="hljs-number">0</span>;<br>        string temp = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (q &lt; thing.<span class="hljs-built_in">length</span>())<br>        &#123;<br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">while</span> (q &lt; thing.<span class="hljs-built_in">length</span>() &amp;&amp; <span class="hljs-built_in">isalpha</span>(thing[q]))<br>            &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(thing[q]);<br>                q++;<br>            &#125;<br>            s.<span class="hljs-built_in">insert</span>(temp);<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (q &lt; thing.<span class="hljs-built_in">length</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(thing[q]))<br>            &#123;<br>                x = x * <span class="hljs-number">10</span> + thing[q] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                q++;<br>            &#125;<br><br><br>            <span class="hljs-keyword">if</span> (!b.<span class="hljs-built_in">count</span>(temp))<span class="hljs-comment">//如果没出现过，则为其编号</span><br>            &#123;<br>                b[temp] = k++;<br>            &#125;<br>            a[b[temp]][i] = x;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*for (int i = 0; i &lt; s.size(); i++)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        for (int j = 0; j &lt; cnt; j++)</span><br><span class="hljs-comment">            cout &lt;&lt; a[i][j] &lt;&lt; &#x27; &#x27;;</span><br><span class="hljs-comment">        cout &lt;&lt; endl;</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-comment">//cout &lt;&lt; &#x27;\n&#x27; &lt;&lt; &#x27;\n&#x27;;</span><br><br>    <span class="hljs-built_in">gauss</span>(a, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>(), cnt);<span class="hljs-comment">//高斯消元</span><br><br>    <span class="hljs-comment">/*for (int i = 0; i &lt; s.size(); i++)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        for (int j = 0; j &lt; cnt; j++)</span><br><span class="hljs-comment">            cout &lt;&lt; a[i][j] &lt;&lt; &#x27; &#x27;;</span><br><span class="hljs-comment">        cout &lt;&lt; endl;</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[i][j] != <span class="hljs-number">0</span>)<br>            &#123;<br>                N++;<br>                flag = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (N &lt; cnt)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Y&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;N&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--)<br>        <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="4-十滴水">4.十滴水</h2>
<p>关心水滴的坐标大小关系，并不关心其具体值是多少。所以，直接用set 存下所有的坐标，每次用 lowerbound 查找目标水滴，然后再将其左右两端进行更新。如果有多个待删水滴，则使用一个优先队列，按照下标排序即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//题目大体思路：用一个结构体来存储有水滴的格子的序号跟水滴数</span><br><span class="hljs-comment">//用set存储该结构体，之后每进行一次操作便将操作的结点在set中删除，并依次向左和向右执行操作</span><br><span class="hljs-comment">//在考虑哪些水滴会炸裂时，用优先队列存储水滴数大于等于5的点，方便每次都是最左边的点先裂开，且能够对所有的点进行处理，不会遗漏</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>	<span class="hljs-type">int</span> x, w;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node&amp; a)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x &lt; a.x;<br>	&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> node&amp; a)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x == a.x &amp;&amp; w == a.w;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> c, m, n;<br>	cin &gt;&gt; c &gt;&gt; m &gt;&gt; n;<br><br>	set&lt;node&gt;s;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>	&#123;<br>		<span class="hljs-type">int</span> x, w;<br>		cin &gt;&gt; x &gt;&gt; w;<br><br>		s.<span class="hljs-built_in">insert</span>(&#123; x,w &#125;);<br><br>	&#125;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		<span class="hljs-type">int</span> p;<br>		cin &gt;&gt; p;<br><br>		<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">lower_bound</span>(&#123; p,<span class="hljs-number">0</span> &#125;);<span class="hljs-comment">//找到要裂开的点</span><br>		<span class="hljs-keyword">auto</span> temp = *it;<br>		s.<span class="hljs-built_in">erase</span>(it);<br>		temp.w++;<br>		s.<span class="hljs-built_in">insert</span>(temp);<br><br>		set&lt;<span class="hljs-type">int</span>&gt;ans;<span class="hljs-comment">//用于存储要裂开的点</span><br><br>		<span class="hljs-keyword">if</span> (temp.w &gt;= <span class="hljs-number">5</span>)ans.<span class="hljs-built_in">insert</span>(temp.x);<br><br>		<span class="hljs-keyword">while</span> (!ans.<span class="hljs-built_in">empty</span>())<br>		&#123;<br>			<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">lower_bound</span>(&#123;*ans.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">0</span>&#125;);<br>			ans.<span class="hljs-built_in">erase</span>(ans.<span class="hljs-built_in">begin</span>());<br>			<span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">begin</span>())<br>			&#123;<br>				<span class="hljs-keyword">auto</span> it1 = it ;<br>				it1--;<br>				<span class="hljs-keyword">auto</span> temp = *it1;<br>				s.<span class="hljs-built_in">erase</span>(it1);<br>				temp.w++;<br>				s.<span class="hljs-built_in">insert</span>(temp);<br>				<span class="hljs-keyword">if</span> (temp.w &gt;= <span class="hljs-number">5</span>)ans.<span class="hljs-built_in">insert</span>(temp.x);<br>			&#125;<br>			<span class="hljs-keyword">auto</span> it2 = it;<br>			it2++;<br>			<span class="hljs-keyword">if</span> (it2 != s.<span class="hljs-built_in">end</span>())<br>			&#123;<br>				<span class="hljs-keyword">auto</span> temp = *it2;<br>				s.<span class="hljs-built_in">erase</span>(it2);<br>				temp.w++;<br>				s.<span class="hljs-built_in">insert</span>(temp);<br>				<span class="hljs-keyword">if</span> (temp.w &gt;= <span class="hljs-number">5</span>)ans.<span class="hljs-built_in">insert</span>(temp.x);<br>			&#125;<br>			s.<span class="hljs-built_in">erase</span>(it);<br>		&#125;<br>		cout &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>csp</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体运算符重定向</title>
    <url>/2024/05/09/%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<h4 id="举个例子">举个例子</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>	<span class="hljs-type">int</span> x, w;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node&amp; a)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x &lt; a.x;<br>	&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> node&amp; a)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x == a.x &amp;&amp; w == a.w;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>上式重定向了小于和等于运算符</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度算法</title>
    <url>/2024/05/01/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
