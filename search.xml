<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pr的一些简易转场</title>
    <url>/2025/05/16/pr%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E6%98%93%E8%BD%AC%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="pr简易转场">PR简易转场</h1>
<h2 id="黑场过渡">黑场过渡</h2>
<p>在效果栏搜黑场过渡</p>
<p><img src="https://pic1.imgdb.cn/item/6827127e58cb8da5c8f6dd69.png" alt=""></p>
<p>直接拖拽到想用的视频片段处，可以通过鼠标自行拉拽，调整过渡时长</p>
<p><img src="https://pic1.imgdb.cn/item/6827128258cb8da5c8f6dd99.png" alt=""></p>
<p>效果:前一个视频末尾渐暗（长度自定义）</p>
<hr>
<h2 id="交叉溶解">交叉溶解</h2>
<p>在效果框中搜索交叉溶解</p>
<p><img src="https://pic1.imgdb.cn/item/6827128558cb8da5c8f6ddac.png" alt=""></p>
<p>勾选交叉溶解了之后，在两个视频片段的交接处右键点击，勾选应用默认过渡，即可完成交叉溶解转场。</p>
<p>效果：前一个视频逐渐透明化，后一个视频逐渐清晰。</p>
<hr>
<h2 id="光效转场">光效转场</h2>
<p>首先在项目中创建一个调整图层，后拖拽到两个视频片段的交界处</p>
<p><img src="https://pic1.imgdb.cn/item/6827128f58cb8da5c8f6de1f.png" alt=""></p>
<p>将调整图层缩放为帧大小，裁剪为交界处前10帧，交界处后5帧的长度。</p>
<p>然后将图层的光晕中心与前一个视频片段的最亮的位置对齐</p>
<p><img src="https://pic1.imgdb.cn/item/6827129e58cb8da5c8f6dec3.png" alt=""></p>
<p>之后通过设置光晕亮度的关键帧（在交接处前面10帧的位置），将调整图层起始处的光晕亮度设为0，交界处拉满，调整图层末尾的光晕亮度设为0。</p>
<p>完成光效转场。</p>
]]></content>
      <categories>
        <category>pr</category>
      </categories>
      <tags>
        <tag>基础工具</tag>
        <tag>pr</tag>
      </tags>
  </entry>
  <entry>
    <title>shell学习</title>
    <url>/2024/04/28/shell%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="什么是shell">什么是Shell?</h2>
<p>Shell是一种用户与计算机进行交互的文字接口，也是一种脚本语言。</p>
<hr>
<h2 id="shell有什么用？">Shell有什么用？</h2>
<p>允许用户执行程序，查找文件，操作文件，输入并获取某种半结构化的输出</p>
<hr>
<h2 id="shell的使用">Shell的使用</h2>
<p>注意：此教程使用于类Unix shell，例如 Bash 或 ZSH，所以如果你的电脑是Mac或者Linux系统，则可以直接开始学习。<br>
如果您的电脑是Windows系统，请使用Wsl或者Linus虚拟机。</p>
<h4 id="在shell中导航">在Shell中导航</h4>
<p>shell中的路径时一组被分割的目录，<code>/</code>代表系统的根目录。</p>
<p>路径分为相对路径与绝对路径。</p>
<p>相对路径指的是相对当前的目录的路径，当前工作目录可以用<code>pwd</code>命令来获取。</p>
<p>绝对路径都是以<code>/</code>开头，可以认为是仅凭借绝对路径就能够找到文件的位置(相对路径无法做到这一点)</p>
<p>在相对路径表示中,<code>.</code>表示当前目录，<code>..</code>表示上级目录。</p>
<p>切换工作目录用<code>cd</code>操作来完成，格式为<code>cd 路径</code></p>
<p>下面举几个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd .. # 进入上级目录<br>pwd # 显示当前目录<br>/mnt/d/Onedrive # 当前目录<br> cd ./桌面 # 进入桌面目录<br>pwd # 查看当前目录<br>/mnt/d/Onedrive/桌面 # 当前目录<br></code></pre></td></tr></table></figure>
<p>以上操作完成了切入桌面这一目录的操作。</p>
<hr>
<h4 id="ls命令">ls命令</h4>
<p>作用：查看指定目录下包含哪些文件。</p>
<p>语法：<code>ls 路径</code></p>
<p>如果没有指定参数，ls打印当前目录下的文件</p>
<hr>
<h4 id="标记和选项">标记和选项</h4>
<p>什么是标记和选项呢？它们以<code>-</code>开头，可以改变程序的行为。</p>
<p>通常，在执行程序的时候使用<code>-h</code>或者<code>-help</code>来打印帮助信息。</p>
<p>下面举一个使用标记和选项的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -l ./文件夹合集<br></code></pre></td></tr></table></figure>
<p>通过<code>ls -help</code>中的帮助信息可以知道<code>ls -l</code>的作用是更加详细地列出目录文件或文件夹下的信息。</p>
<p>当我输入这个指令后，交互界面会打印出例如以下的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">drwxrwxrwx 1 borwin borwin 4096 Mar 15 01:15  my_python<br>drwxrwxrwx 1 borwin borwin 4096 Mar  9 22:29  pytorch学习<br></code></pre></td></tr></table></figure>
<p>前面一串字符串中d表示文件夹合集是一个目录，然后接下来的九个字符，每三个字符一组(rwx),它们分别代表了文件所有者、用户组以及其它所有人具有的权限。</p>
<p>r代表可读权限，w代表可写权限，x代表可执行权限(搜索权限)，如果不具有该权限，系统会打印出<code>r-x</code>之类的字符串，代表不具有修改权限。</p>
<hr>
<h4 id="mv命令">mv命令</h4>
<p>作用：为文件或者目录重命名，或者将文件或目录移动到其它位置。</p>
<p>语法：<br>
<code>mv [options] source dest</code></p>
<p><code>mv [options] source... directory</code></p>
<p>对options中的参数说明：</p>
<ul>
<li>-b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。</li>
<li>-i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。</li>
<li>-f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。</li>
<li>-n: 不要覆盖任何已存在的文件或目录。</li>
<li>-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</li>
</ul>
<p>mv参数的设置与运行结果一般有以下几种情况：</p>
<table>
<thead>
<tr>
<th>参数的设置</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>mv source_file(文件) dest_file(文件)</td>
<td>将源文件名 source_file 改为目标文件名 dest_file</td>
</tr>
<tr>
<td>mv source_file(文件) dest_directory(目录)</td>
<td>将文件 source_file 移动到目标目录 dest_directory 中</td>
</tr>
<tr>
<td>mv source_directory(目录) dest_directory(目录)</td>
<td>目录名 dest_directory 已存在，将 source_directory 移动到目录名 dest_directory 中；目录名 dest_directory 不存在则 source_directory 改名为目录名 dest_directory</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="cp命令">cp命令</h4>
<p>作用:复制文件或者目录(包含粘贴操作)</p>
<p>语法：<code>cp [options] source dest</code></p>
<p>对options中的参数加以说明：</p>
<ul>
<li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。</li>
<li>-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。</li>
<li>-r 或 --recursive：用于复制目录及其所有的子目录和文件，如果要复制目录，需要使用该选项</li>
<li>-i 或 --interactive：在复制前提示确认，如果目标文件已存在，则会询问是否覆盖，回答 y 时目标文件将被覆盖。</li>
<li>-u 或 --update：仅复制源文件中更新时间较新的文件。</li>
<li>-v 或 --verbose：显示详细的复制过程。</li>
<li>-p 或 --preserve：保留源文件的权限、所有者和时间戳信息。</li>
<li>-f 或 --force：强制复制，即使目标文件已存在也会覆盖，而且不给出提示。</li>
<li>-l：不复制文件，只是生成链接文件。</li>
</ul>
<p>下面举几个例子：</p>
<table>
<thead>
<tr>
<th>参数的设置</th>
<th>运行的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>cp file.txt /path/to/destination/</td>
<td>将文件 file.txt 复制到目录 /path/to/destination/ 中</td>
</tr>
<tr>
<td>cp –r test/ newtest</td>
<td>将当前目录 test/ 下的所有文件复制到新目录 newtest 下</td>
</tr>
<tr>
<td>cp -i file.txt /path/to/destination/</td>
<td>复制文件，并在目标文件已存在时进行确认</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="mkdir命令">mkdir命令</h4>
<p>作用：创建目录</p>
<p>语法：<code>mkdir [-p] dirName</code></p>
<p>参数说明：-p 确保目录名称存在，不存在的就建一个。</p>
<p>参数设置与运行结果：</p>
<table>
<thead>
<tr>
<th>参数的设置</th>
<th>运行的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>mkdir runoob</td>
<td>在工作目录下，建立一个名为 runoob 的子目录</td>
</tr>
<tr>
<td>mkdir -p runoob2/test</td>
<td>在工作目录下的 runoob2 目录中，建立一个名为 test 的子目录,若 runoob2 目录原本不存在，则建立一个</td>
</tr>
</tbody>
</table>
<p>注意：在上面的第二个例子中若不加 -p 参数，且原本 runoob2 目录不存在，则产生错误。</p>
<hr>
<h4 id="用户手册">用户手册</h4>
<p>如果想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，可以用<code>man</code>程序查看其用户手册。</p>
<p>例如<code>man ls</code>就能查看<code>ls</code>程序的用户手册</p>
<hr>
<h4 id="在程序之间创建连接">在程序之间创建连接</h4>
<p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！</p>
<p>最简单的两种重定向是<code>&lt; file</code>与<code>&gt; file</code>,分别为程序的输入重定向与输出的重定向</p>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">missing:~$ echo hello &gt; hello.txt<br>missing:~$ cat hello.txt<br>hello<br>missing:~$ cat &lt; hello.txt<br>hello<br>missing:~$ cat &lt; hello.txt &gt; hello2.txt<br>missing:~$ cat hello2.txt<br>hello<br></code></pre></td></tr></table></figure>
<p>除此之外，还可以使用<code>&gt;&gt;</code>来进行文件的最佳操作（即在文件的末尾追加内容）</p>
<p>重定向还可以依赖于管道<code>|</code>来将一个程序的输出于另一个程序的输入连接起来</p>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">missing:~$ ls -l / | tail -n1<br>drwxr-xr-x 1 root  root  4096 Jun 20  2019 var<br>missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#x27; &#x27; -f2<br>219<br></code></pre></td></tr></table></figure>
<hr>
<h4 id="sudo命令">sudo命令</h4>
<p>作用:以管理者的身份来执行程序，不会受到权限的限制</p>
<hr>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>基础工具</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/2024/04/28/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="快排">快排</h2>
<p>时间复杂度为O(nlogn)</p>
<p>算法概述：快排排序算法的核心是分治算法，往细一点讲就是：指定一个中间值，对序列进行划分，左部分全部小于该中间值，右部分全部大于中间值</p>
<p>之后再对所划分成的两个部分再进行划分（递归处理），最后达成排序的效果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid=a[l+r&gt;&gt;<span class="hljs-number">1</span>],le=l<span class="hljs-number">-1</span>,re=r+<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(le&lt;re)<br>    &#123;<br>        <span class="hljs-keyword">do</span> le++; <span class="hljs-keyword">while</span>(a[le]&lt;mid);<br>        <span class="hljs-keyword">do</span> ri--; <span class="hljs-keyword">while</span>(a[ri]&gt;mid);<br>        <span class="hljs-keyword">if</span>(le&lt;ri)<span class="hljs-built_in">swap</span>(a[le],a[ri]);<br>    &#125;<br>    <br>    <span class="hljs-built_in">quick_sort</span>(l,re);<br>    <span class="hljs-built_in">quick_sort</span>(re+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可能会有人对以下递归中的参数有所疑问</p>
<p><code>quick_sort(l,re); quick_sort(re+1,r);</code></p>
<p>re指向的是从右到左的第一个小于mid的数，相当于要对从l到re进行排序，从re+1到r进行排序,这样解释是不是容易懂一些了呢？</p>
<hr>
<h2 id="归并排序">归并排序</h2>
<p>时间复杂度:O(nlogn)</p>
<p>分治的思想，及将序列分成两个部分，将这两个部分分别排序,之后合并为一个序列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],l,r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归结束条件</span><br>    <br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>,le=l,ri=mid+<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-built_in">merge_sort</span>(a,l,mid);<span class="hljs-built_in">merge_sort</span>(a,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//分别排序</span><br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt;c;<span class="hljs-comment">//用于暂存合并后的排序好的数组</span><br>    <br>    <span class="hljs-keyword">while</span>(le&lt;ri)<span class="hljs-comment">//合并数组</span><br>        <span class="hljs-keyword">if</span>(a[le]&lt;=a[ri])c.<span class="hljs-built_in">push_back</span>(a[le++]);<br>        <span class="hljs-keyword">else</span> c.<span class="hljs-built_in">push_back</span>(a[ri++]);<br>    <br>    <span class="hljs-comment">//可能会出现一边没有填入vector完的情况</span><br>    <span class="hljs-keyword">while</span>(le&lt;=mid)c.<span class="hljs-built_in">push_back</span>(a[le++]);<br>    <span class="hljs-keyword">while</span>(ri&lt;=r)c.<span class="hljs-built_in">push_back</span>(a[ri++]);<br>    <br>    <span class="hljs-comment">//将暂存的数据填入原来的数组中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,k=<span class="hljs-number">0</span>;i&lt;=r;i++,k++)a[i]=c[k];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实在算法题中直接调用sort函数就行了(在数组比较短的时候是插入排序，数组比较长的时候是快排)，了解以上两种排序算法其实是加深对分治的理解，除了这几种排序算法外还有冒泡排序、选择排序等算法。</p>
<p>排序算法能够做到的最好的时间复杂度就是O(nlogn)了。</p>
<hr>
<h2 id="二分">二分</h2>
<p>此模板不用考虑mid+1或mid-1的情况,比Y总的模板好用qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> l=<span class="hljs-number">-1</span>,r=n;<span class="hljs-comment">//n为数组长度,数组从0开始存储时这样初始化</span><br><span class="hljs-keyword">while</span>(l+<span class="hljs-number">1</span>!=r)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>())l=mid;<br>    <span class="hljs-keyword">else</span> r=mid;<br>&#125;<span class="hljs-comment">//最后根据实际情况选取l或者r作为结果</span><br></code></pre></td></tr></table></figure>
<h4 id="下面详细讲一下这串代码">下面详细讲一下这串代码:</h4>
<h5 id="为什么l的初始值为-1-r的初始值为n">为什么L的初始值为-1，R的初始值为N?</h5>
<p>这样赋值可以保证数组不会越界</p>
<h5 id="为什么循环结束的条件是while-l-1-r">为什么循环结束的条件是while(L+1!=R)?</h5>
<p>之前学过二分的小伙伴可能会发现，之前学的二分，他循环结束的条件是while(L&lt;R)</p>
<p>而这边给出的循环条件是while(L+1!=R) 其实，就是当L和R相邻的时候，循环就结束，而原本的while(L&lt;R)</p>
<p>是当两区间重合以后，循环才结束，所以之前我们需要判断对mid进行加一或者减一的操作，而且因为区间重合的问题，最后返回的L、R还要再进行判断，而这边的这个二分，因为区间反回的是不重合的两区间，只有L=mid和R=mid这两种情况，最后根据需要返回L或者R；</p>
<h5 id="为什么不会陷入死循环">为什么不会陷入死循环?</h5>
<p>对于比较奇葩的情况，比如数组大小为1或者2</p>
<p>比如int a[1],b[2];</p>
<p>由于我们是while(L+1!=R)结束循环，也就是当L和R相邻的时候结束条件</p>
<p>对于a[1],他的下标为0 此时L=-1，R=n也就是1</p>
<p>对于b[2],他的下标为0,1 此时L=-1，R=n也就是2</p>
<p>所以无论何种情况，初始的L+1始终小于R，历经循环后最终L和R相邻，不会出现一开始L就和R重合等情况导致出现while(L+1!=R)循环不能结束的情况</p>
<hr>
<h2 id="前缀和">前缀和</h2>
<p>前缀和算法适用于要经常取出数组中某一段的和的时候，能够将O(n)的取和操作优化为O(1)<br>
就像它的名字一样，前缀和就是从数组开头一直到某个序号处的所有元素的和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//假如有数组a[n+1],元素个数为n,从a[1]开始记录数据</span><br><span class="hljs-type">int</span> head_sum[n];<br>head_sum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)head_sum[i]=head_sum[i<span class="hljs-number">-1</span>]+a[i];<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="差分">差分</h2>
<p>差分数组可以说是取前缀的逆运算，差分数组的前缀和数组为原数组，差分用于对某一段连续的区间进行加减操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sub[n];<br>sub[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)sub[i]=a[i]-a[i<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="双指针">双指针</h2>
<p>双指针在多数情况下为左右指针与快慢指针的应用，当然也有一些情况需要灵活运用，下面举两个具体的例子，分别是左右指针与快慢指针的。</p>
<h4 id="左右指针">左右指针</h4>
<p>题目:输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>显然，这题用暴力做法的时间复杂度为O(n^2),但是如果我们用双指针就大不一样了(O(n))，见如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//假定一定存在这样的一对数的和为s,假设我们已知数组的长度为n,且从1开始存储数据</span><br><span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=n,res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br>    <span class="hljs-keyword">while</span>(a[l]+a[r]&gt;s &amp;&amp; l&lt;r)r--;<br>    <span class="hljs-keyword">if</span>(a[l]+a[r]==s)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,a[l],a[r]);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    l++;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解释一下上面的代码中的为什么可以直接<code>l++;</code>,而不用重置r:</p>
<p>当右指针扫描至a[l]+a[r]&lt;s的位置时,满足a[l]+a[s+1]&gt;s,这时将l指针向右移动,由于a[l+1]&gt;a[l],所以此时a[l]+a[r+1]&gt;s,所以r保持不变，继续向前遍历是合理的。</p>
<h4 id="快慢指针">快慢指针</h4>
<p>举个简单的例子：输出链表中间位置的值.</p>
<p>何为快指针？何为慢指针？简单一点理解，走的快的为快指针，走的慢的为慢指针。</p>
<p>例如在这题中，我们将快指针与慢指针都初始化为头指针，然后画快指针一次向后移动两步，慢指针一次向后移动1步，这样，在快指针到达终点的时候，满指针恰好到达中间的位置。</p>
<p>由于过于简单，此处不用代码加以说明。</p>
<hr>
<h4 id="离散化">离散化</h4>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学（上）期末复习</title>
    <url>/2024/05/07/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%8A%EF%BC%89%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="思维导图持续更新中">思维导图持续更新中…</h2>
<p><a href="https://gitmind.cn/app/docs/m3jtdt2i">离散数学（上）</a></p>
<p>点击以上链接😉</p>
]]></content>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>利用shell解决的一些问题</title>
    <url>/2024/05/02/%E5%88%A9%E7%94%A8shell%E8%A7%A3%E5%86%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-在-tmp-下新建一个名为-missing-的文件夹">1.在 /tmp 下新建一个名为 missing 的文件夹</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ~/tmp<br>mkdir missing<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="2-用-touch-在-missing-文件夹中新建一个叫-semester-的文件">2.用 touch 在 missing 文件夹中新建一个叫 semester 的文件</h2>
<p>首先学习了一下touch的用法</p>
<p>作用：修改文件或者目录的时间属性，包括存取时间和更改时间。如果文件不存在，就建立一个新的文件</p>
<p>语法：<code>touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</code></p>
<p>参数说明：</p>
<ul>
<li>a 改变档案的读取时间记录。</li>
<li>m 改变档案的修改时间记录.</li>
<li>c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。</li>
<li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li>
<li>r 使用参考档的时间记录，与 --file 的效果一样。</li>
<li>d 设定时间与日期，可以使用各种不同的格式。</li>
<li>t 设定档案的时间记录，格式与 date 指令相同。</li>
<li>–no-create 不会建立新档案。</li>
<li>–help 列出指令格式。</li>
<li>–version 列出版本讯息。</li>
</ul>
<p>实例与运行效果：</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>运行效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>touch testfile</td>
<td>修改文件&quot;testfile&quot;的时间属性为当前系统时间</td>
</tr>
<tr>
<td>touch file</td>
<td>使用指令&quot;touch&quot;时，如果指定的文件不存在，则将创建一个新的空白文件</td>
</tr>
</tbody>
</table>
<p>可以用<code>ls -l</code>来查看时间属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd missing<br>touch semester<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="3-将以下内容一行一行地写入-semester-文件：">3.将以下内容一行一行地写入 semester 文件：</h2>
<p><code>#!/bin/sh</code></p>
<p><code>curl --head --silent https://missing.csail.mit.edu</code></p>
<p>这个题涉及到转义的问题，如果直接用双引号的话，!在双引号中也有特殊含义，下面详细讲一下shell中的转义问题。</p>
<p>shell中的转义有三种途径：<code>\</code> <code>''</code> 与 <code>&quot;&quot;</code></p>
<h4 id="三种转义方法的使用范围">三种转义方法的使用范围</h4>
<h5 id="1">1.<code>\</code></h5>
<p><code>\</code>的范围是最广的,几乎可以对所有的特殊字符进行转义</p>
<h5 id="2">2.<code>'</code></h5>
<p><code>'</code>将会对其所包含的内容不加修饰，转义出来的内容就是所包含的内容,一个字符也不会改变</p>
<h5 id="3">3.’&quot;’</h5>
<p><code>&quot;</code>的使用范围比<code>'</code>小，<code>&quot;</code>会先将所包含的内容在shell中运行之后再进行输出</p>
<p>例如&quot;tell me the date&quot;:这段字符中的date将会被shell运行，替换为当时的日期</p>
<p>此外，shell中的特殊字符都会保留有特殊含义，再显示之前都会对其评估</p>
<p>经以上总结，我们可以简单的写出这题的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo &#x27;#!/bin/sh<br> curl --head --silent https://missing.csail.mit.edu&#x27; &gt; semester.txt<br></code></pre></td></tr></table></figure>
<h2 id="4-使用-chmod-命令改变权限-使-semester-能够成功执行">4. 使用 chmod 命令改变权限，使 ./semester 能够成功执行</h2>
<p>在我们直接在命令行输入<code>.\semester</code>时,我们会得到<code>Permission denied</code>,这是由于权限不够。</p>
<p>在输入<code>ls -l</code>之后，我们得到<code>rw-r--r--</code>,发现没有搜索的权限，所以我们无法运行程序，这时我们需要<code>chmod</code>命令来改变权限</p>
<p><code>chmod</code></p>
<p>作用：控制用户对文件的权限的命令</p>
<p>语法：<code>chmod [-cfvR] [--help] [--version] mode file...</code></p>
<p>参数说明：</p>
<ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是</li>
<li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行</li>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<p><img src="/picture/rwx.jpg" alt="示例"></p>
<p>如上面的图片，该变权限实际上就是改变指定区域的字符，改变方式有八进制方式与符号模式。</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>chmod ugo+r file1.txt</td>
<td>将文件 file1.txt 设为所有人皆可读取</td>
</tr>
<tr>
<td>chmod a+r file1.txt</td>
<td>将文件 file1.txt 设为所有人皆可读取</td>
</tr>
<tr>
<td>chmod -R a+r *</td>
<td>将目前目录下的所有文件与子目录皆设为任何人可读取</td>
</tr>
<tr>
<td>chmod 777 file</td>
<td>将该目录对与所有对象的权限都设为rwx</td>
</tr>
</tbody>
</table>
<p>所以解决这一题我们用如下的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">chmod u+x ./semester # 让文件所有者有搜索的权限<br>./semester # 运行程序<br></code></pre></td></tr></table></figure>
<p>下面解释一下运行代码中第一行的<code>#!/bin/sh</code></p>
<p><code>#!</code>被称为Shebang(Hashbang),在文件中存在Shebang的情况下，类Unix操作系统的程序加载器会分析Shebang后的内容，将这些内容作为解释器指令，并调用该指令，并将载有Shebang的文件路径作为该解释器的参数。</p>
<p>所以在这里相当于这句话的作用是调用/bin/sh程序来执行下面的代码</p>
<h2 id="5-使用-和-将-semester-文件输出的最后更改日期信息-写入主目录下的-last-modified-txt-的文件中">5. 使用 | 和 &gt; ，将 semester 文件输出的最后更改日期信息，写入主目录下的 last-modified.txt 的文件中</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./semester | grep last-modified &gt; ~/last-modified.txt<br></code></pre></td></tr></table></figure>
<p>借助将管道的输出信息输出给<code>grep</code>,然后<code>grep</code>查找输出中以<code>last-modified</code>开头的信息，然后重定向输出到主文件夹的<code>last-modified.txt</code>中</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>基础工具</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>第30次csp认证题解</title>
    <url>/2024/05/29/%E7%AC%AC30%E6%AC%A1csp%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="重复局面">重复局面</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>map&lt;string,<span class="hljs-type">int</span>&gt;m;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    string s[<span class="hljs-number">110</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">8</span>;j++)<br>        &#123;<br>            string tep;<br>            cin&gt;&gt;tep;<br>            s[i]+=tep;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!(m.<span class="hljs-built_in">count</span>(s[i])))<br>        &#123;<br>            m[s[i]]=<span class="hljs-number">1</span>;<br>            cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            m[s[i]]++;<br>            cout&lt;&lt;m[s[i]]&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="矩阵运算">矩阵运算</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e4</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> D = <span class="hljs-number">25</span>;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>); cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> n, d;<br>    <span class="hljs-type">int</span> Q[N][D], K[N][D], V[N][D], w[N], tep[N][D] = &#123; <span class="hljs-number">0</span> &#125;, end[N][D] = &#123; <span class="hljs-number">0</span> &#125;;<br>    cin &gt;&gt; n &gt;&gt; d;<br><br>    <span class="hljs-comment">//cin juzhen</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= d; j++)cin &gt;&gt; Q[i][j];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= d; j++)cin &gt;&gt; K[i][j];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= d; j++)cin &gt;&gt; V[i][j];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)cin &gt;&gt; w[i];<br><br>    <span class="hljs-comment">//K^T*V</span><br>    <span class="hljs-comment">//memset(tep,1,sizeof(tep));</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= d; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= d; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = <span class="hljs-number">1</span>; m &lt;= n; m++)<br>                tep[i][j] += K[m][i] * V[m][j];<br>        &#125;<br><br>    <span class="hljs-comment">//q*tep</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= d; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = <span class="hljs-number">1</span>; m &lt;= d; m++)<br>            &#123;<br>                end[i][j] += Q[i][m] * tep[m][j];<br>            &#125;<br>        &#125;<br><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= d; j++)<br>        &#123;<br>            cout &lt;&lt; end[i][j] * w[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == d];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="解压缩">解压缩</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 2000007</span><br><br><span class="hljs-type">int</span> b[N], tot;<br><br><span class="hljs-type">int</span> Data[N * <span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> o, <span class="hljs-type">int</span> l)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (o &gt;= l) &#123;<br>        <span class="hljs-type">int</span> p = tot - o + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= l; ++i) Data[++tot] = Data[p++];<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> pp = tot - o + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> p = pp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= l; ++i) &#123;<br>            Data[++tot] = Data[p++];<br>            <span class="hljs-keyword">if</span> (i % o == <span class="hljs-number">0</span>) p = pp;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">10</span>) <span class="hljs-built_in">putchar</span>(x + <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">putchar</span>(x + <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-built_in">pt</span>(x &gt;&gt; <span class="hljs-number">4</span>); <span class="hljs-built_in">pt</span>(x &amp; <span class="hljs-number">15</span>); &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-type">bool</span> f = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, x; i &lt;= n; ++i) &#123;<br>        <span class="hljs-type">char</span> c = <span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">isdigit</span>(c) &amp;&amp; !<span class="hljs-built_in">isalpha</span>(c)) c = <span class="hljs-built_in">getchar</span>();<br>        x = <span class="hljs-built_in">isdigit</span>(c) ? (c - <span class="hljs-string">&#x27;0&#x27;</span>) : (c - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">10</span>);<br>        c = <span class="hljs-built_in">getchar</span>();<br>        x = (x &lt;&lt; <span class="hljs-number">4</span>) + (<span class="hljs-built_in">isdigit</span>(c) ? (c - <span class="hljs-string">&#x27;0&#x27;</span>) : (c - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">10</span>));<br>        <span class="hljs-keyword">if</span> (f) b[++tot] = x;<br>        <span class="hljs-keyword">if</span> ((x &amp; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>)) == <span class="hljs-number">0</span>) f = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//print(x); puts(&quot;!&quot;);</span><br>    &#125;<br>    n = tot; tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//printf(&quot;%d\n&quot;, n);</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> ((b[i] &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// data</span><br>            <span class="hljs-type">int</span> l = b[i] &gt;&gt; <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (l &gt;= <span class="hljs-number">60</span>) &#123;<br>                <span class="hljs-type">int</span> tmpk = l - <span class="hljs-number">59</span>; l = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + tmpk; j &gt; i; --j) l = (l &lt;&lt; <span class="hljs-number">8</span>) + b[j];<br>                i += tmpk;<br>            &#125;<br>            ++l;<br>            <span class="hljs-comment">//printf(&quot;%d\n&quot;, l);</span><br>            <span class="hljs-keyword">for</span> (; l; --l) Data[++tot] = b[++i];<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((b[i] &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> l = ((b[i] &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">7</span>) + <span class="hljs-number">4</span>;<br>            <span class="hljs-type">int</span> o = ((b[i] &gt;&gt; <span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-number">8</span>);<br>            o += b[++i];<br>            <span class="hljs-comment">//printf(&quot;%d %d\n&quot;, l, o);</span><br>            <span class="hljs-built_in">add</span>(o, l);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> l = (b[i] &gt;&gt; <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> o = (b[i + <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>) + b[i + <span class="hljs-number">1</span>];<br>            i += <span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//printf(&quot;%d %d\n&quot;, l, o);</span><br>            <span class="hljs-built_in">add</span>(o, l);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= tot; ++i) &#123;<br>        <span class="hljs-built_in">print</span>(Data[i]);<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>csp</tag>
      </tags>
  </entry>
  <entry>
    <title>第28次csp认证题解</title>
    <url>/2024/05/29/%E7%AC%AC28%E6%AC%A1csp%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1-现值计算">1、现值计算</h2>
<p>根据题意直接倒着求价值就行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">double</span> money;<br><span class="hljs-type">double</span> i;<span class="hljs-comment">//年利率 </span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b)</span><span class="hljs-comment">//a为转换前的价值，b为年数 </span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> li=i+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> a/<span class="hljs-built_in">pow</span>(li,b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lf&quot;</span>,&amp;n,&amp;i);<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;money);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-type">double</span> temp;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,&amp;temp);<br>        <br>        money+=<span class="hljs-built_in">sum</span>(temp,i);<br>        <br>    &#125;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf&quot;</span>,money);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-训练计划">2、训练计划</h2>
<p>该题可以分解为三个部分，首先是求出最早开始的时间，其次是判断是否能够在n天内完成任务，最后是求出每个科目最晚开始的时间</p>
<p>该题可以以依赖关系建模成一颗树，所依赖的科目为该科目的父节点</p>
<p>这样的话，这个题目所划分成的三个部分可以分别理解为： 求出每个科目到根节点所经过的点的权重和+1;一颗树的最大权重路是否大于n;求出每个科目往下的子树的一条<br>
路的最大权值和sum,用n-sum+1(这里用到简单的dp)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,m;<br><br>vector&lt;<span class="hljs-type">int</span>&gt;a;<br>vector&lt;<span class="hljs-type">int</span>&gt;b;<br><br><span class="hljs-type">int</span> late[<span class="hljs-number">110</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <br>    a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> num;<br>        cin&gt;&gt;num;<br>        a.<span class="hljs-built_in">push_back</span>(num);<span class="hljs-comment">//第i个依赖于num ,即第i个在num前完成</span><br>    &#125;<br>    <br>    b.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> num;<br>        cin&gt;&gt;num;<br>        b.<span class="hljs-built_in">push_back</span>(num);<span class="hljs-comment">//b记录完成所需天数 </span><br>    &#125;<br>    <br>    <span class="hljs-comment">//先计算最早开始时间</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> day=<span class="hljs-number">1</span>,idx=i;<br>        <span class="hljs-keyword">while</span>(a[idx]!=<span class="hljs-number">0</span>)<br>        &#123;<br>            day+=b[a[idx]];<br>            idx=a[idx];<br>        &#125;<br>        cout&lt;&lt;day&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <br>    <span class="hljs-comment">//再计算最晚开始时间</span><br>    <span class="hljs-comment">//首先判断能否在n天内完成 </span><br>    <span class="hljs-type">int</span> max_day=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> idx=i,temp=<span class="hljs-number">0</span>;<span class="hljs-comment">//temp记录该条路的长度 </span><br>        temp+=b[i];<br>        <span class="hljs-keyword">while</span>(a[idx]!=<span class="hljs-number">0</span>)<br>        &#123;<br>            temp+=b[a[idx]];<br>            idx=a[idx];<br>        &#125;<br>        max_day=<span class="hljs-built_in">max</span>(max_day,temp);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(max_day&gt;n)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//下面来计算最晚开始时间</span><br>    <span class="hljs-comment">//late数组记录往后的最长路径(不记本身的天数） </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=m<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;i--)<br>    &#123;<br>         <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=m;j++)<br>         &#123;<br>         	<span class="hljs-keyword">if</span>(a[j]==i)<br>         	&#123;<br>         		late[i]=<span class="hljs-built_in">max</span>(late[i],late[j]+b[j]);<br>            &#125;<br>         &#125;<br>    &#125; <br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)cout&lt;&lt;n-late[i]-b[i]+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-jpeg解码">3、JPEG解码</h2>
<p>大模拟题，根据近几年题目来看，应该是最简单的一个第三题，没有卡数据范围，也没有很臭很长什么的</p>
<p>这个题目的解决步骤已经在题干中说明了(你只需要跟着题意敲就行了)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">double</span> Q[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>],M[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>],M0[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>],M1[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>],M2[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<br><br><span class="hljs-type">int</span> n,T;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先读入量化矩阵Q </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">8</span>;j++)<br>            cin&gt;&gt;Q[i][j];<br>            <br>    cin&gt;&gt;n&gt;&gt;T;<br>    <span class="hljs-comment">//然后按指定方法填入M矩阵</span><br>    <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> num;<br>        cin&gt;&gt;num;<br>        <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>&amp;&amp;y%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)M[x][y++]=num;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>&amp;&amp;y&amp;<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)M[x++][y--]=num;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>&amp;&amp;x%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">7</span>)M[x][y++]=num;<br>            <span class="hljs-keyword">else</span> M[x++][y]=num;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y==<span class="hljs-number">0</span>&amp;&amp;x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(x==<span class="hljs-number">0</span>)M[x][y++]=num;<br>            <span class="hljs-keyword">else</span> M[x--][y++]=num;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x==<span class="hljs-number">7</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(y%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)M[x][y++]=num;<br>            <span class="hljs-keyword">else</span> M[x--][y++]=num;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(y==<span class="hljs-number">7</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)M[x++][y--]=num;<br>            <span class="hljs-keyword">else</span> M[x++][y]=num;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((x+y)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)M[x--][y++]=num;<br>        <span class="hljs-keyword">else</span> M[x++][y--]=num;<br>    &#125;<br>    <br><span class="hljs-comment">//	//M0调错</span><br><span class="hljs-comment">//	 for(int i=0;i&lt;8;i++)</span><br><span class="hljs-comment">//		&#123;</span><br><span class="hljs-comment">//			for(int j=0;j&lt;8;j++)</span><br><span class="hljs-comment">//			&#123;</span><br><span class="hljs-comment">//				cout&lt;&lt;M[i][j]&lt;&lt;&#x27; &#x27;;</span><br><span class="hljs-comment">//			&#125;</span><br><span class="hljs-comment">//			cout&lt;&lt;&#x27;\n&#x27;;</span><br><span class="hljs-comment">//		&#125;</span><br>    <span class="hljs-comment">//进行乘相应元素的计算</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">8</span>;j++)<br>        &#123;<br>            M0[i][j]=M[i][j]*Q[i][j];<br>        &#125;<br>        <br><span class="hljs-comment">//	//M0调错</span><br><span class="hljs-comment">//	 for(int i=0;i&lt;8;i++)</span><br><span class="hljs-comment">//		&#123;</span><br><span class="hljs-comment">//			for(int j=0;j&lt;8;j++)</span><br><span class="hljs-comment">//			&#123;</span><br><span class="hljs-comment">//				cout&lt;&lt;M0[i][j]&lt;&lt;&#x27; &#x27;;</span><br><span class="hljs-comment">//			&#125;</span><br><span class="hljs-comment">//			cout&lt;&lt;&#x27;\n&#x27;;</span><br><span class="hljs-comment">//		&#125;</span><br>    <span class="hljs-comment">//进行离散余弦逆变换</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">8</span>;j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;<span class="hljs-number">8</span>;u++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;<span class="hljs-number">8</span>;v++)<br>            &#123;<br>                <span class="hljs-type">double</span> au,av;<br>                <span class="hljs-keyword">if</span>(u==<span class="hljs-number">0</span>)au=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">0.5</span>);<br>                <span class="hljs-keyword">else</span> au=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(v==<span class="hljs-number">0</span>)av=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">0.5</span>);<br>                <span class="hljs-keyword">else</span> av=<span class="hljs-number">1</span>;<br>                M1[i][j]+=<span class="hljs-number">0.25</span>*au*av*M0[u][v]*<span class="hljs-built_in">cos</span>(<span class="hljs-number">0.125</span>*(i+<span class="hljs-number">0.5</span>)*u*<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>))*<span class="hljs-built_in">cos</span>(<span class="hljs-number">0.125</span>*<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>)*(j+<span class="hljs-number">0.5</span>)*v);<br>            &#125;<br>    <br><span class="hljs-comment">//	//M1调错</span><br><span class="hljs-comment">//	</span><br><span class="hljs-comment">//		for(int i=0;i&lt;8;i++)</span><br><span class="hljs-comment">//		&#123;</span><br><span class="hljs-comment">//			for(int j=0;j&lt;8;j++)</span><br><span class="hljs-comment">//			&#123;</span><br><span class="hljs-comment">//				cout&lt;&lt;M1[i][j]&lt;&lt;&#x27; &#x27;;</span><br><span class="hljs-comment">//			&#125;</span><br><span class="hljs-comment">//			cout&lt;&lt;&#x27;\n&#x27;;</span><br><span class="hljs-comment">//		&#125;</span><br>    <br>    <span class="hljs-comment">//每个元素加128后四舍五入， 大于255取255，小于0取0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">8</span>;j++)<br>        &#123;<br>            M2[i][j]=M1[i][j]+<span class="hljs-number">128</span>;<br>            M2[i][j]=(<span class="hljs-type">int</span>)(M2[i][j]+<span class="hljs-number">0.5</span>);<br>            <span class="hljs-keyword">if</span>(M2[i][j]&gt;<span class="hljs-number">255</span>)M2[i][j]=<span class="hljs-number">255</span>;<br>            <span class="hljs-keyword">if</span>(M2[i][j]&lt;<span class="hljs-number">0</span>)M2[i][j]=<span class="hljs-number">0</span>;<br>        &#125;<br>    <span class="hljs-comment">//输出结果</span><br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">8</span>;j++)<br>            &#123;<br>                cout&lt;&lt;M[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(T==<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">8</span>;j++)<br>            &#123;<br>                cout&lt;&lt;M0[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(T==<span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">8</span>;j++)<br>            &#123;<br>                cout&lt;&lt;M2[i][j]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-聚集方差">4、聚集方差</h2>
<p>Splay+启发式合并(正在学习中quq)</p>
<p>每一个子树中所有的点都是一个可重集合，并且一个节点的父亲一定包含该节点的可重集合。<br>
每次暴力的将儿子节点的可重集合合并到父节点会超时，但可以考虑每次只将轻儿子的可重集合合并到重儿子的可重集合，时间复杂度就是 O(logn)的。<br>
因为重儿子的子树大小一定不小于轻儿子的子树大小，也就是父节点的子树大小至少是轻儿子的子树大小的2倍，所以最多有 logn 条轻儿子。<br>
由于每次插入一个新的节点到集合中，只会影响相邻的四个节点的方差。所以计算答案时先将之前的贡献删去，再将新产生的贡献加回来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optimize(2)</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> GCC optimize(3,<span class="hljs-string">&quot;Ofast&quot;</span>,<span class="hljs-string">&quot;inline&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">3e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> LL INF=<span class="hljs-number">1e18</span>;<br><span class="hljs-type">int</span> h[N],e[N],ne[N],root[N],_idx,n;<br>LL ans[N],a[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[_idx]=b,ne[_idx]=h[a],h[a]=_idx++;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> son[<span class="hljs-number">2</span>],p;<span class="hljs-comment">//左右儿子 父亲</span><br>    <span class="hljs-type">int</span> size;<span class="hljs-comment">//splay的大小</span><br>    LL v,min,sum;<span class="hljs-comment">//v:员工的工作时间 sum:方差 min:splay上其他节点到该节点最短距离的平方</span><br>&#125;tr[N];<br><span class="hljs-type">int</span> idx;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_node</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    idx++;<br>    tr[idx].v=v,tr[idx].p=p;<br>    tr[idx].sum=<span class="hljs-number">0</span>,tr[idx].min=INF;<br>    tr[idx].size=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> idx;<br>&#125;<br><span class="hljs-function">LL <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (tr[u].v-tr[v].v)*(tr[u].v-tr[v].v);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-type">int</span> l=tr[u].son[<span class="hljs-number">0</span>],r=tr[u].son[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//不是空节点才计算最小值</span><br>    <span class="hljs-keyword">if</span>(tr[u].p)tr[u].min=<span class="hljs-built_in">min</span>(tr[u].min,<span class="hljs-built_in">calc</span>(u,tr[u].p));<br>    <span class="hljs-keyword">if</span>(l)tr[u].min=<span class="hljs-built_in">min</span>(tr[u].min,<span class="hljs-built_in">calc</span>(u,l));<br>    <span class="hljs-keyword">if</span>(r)tr[u].min=<span class="hljs-built_in">min</span>(tr[u].min,<span class="hljs-built_in">calc</span>(u,r));<br>    tr[u].sum=tr[u].min+tr[l].sum+tr[r].sum;<br>    tr[u].size=tr[l].size+tr[r].size+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> y=tr[x].p,z=tr[y].p;<br>    <span class="hljs-type">int</span> k=(x==tr[y].son[<span class="hljs-number">1</span>]);<br>    tr[z].son[y==tr[z].son[<span class="hljs-number">1</span>]]=x,tr[x].p=z;<br>    tr[y].son[k]=tr[x].son[k^<span class="hljs-number">1</span>],tr[tr[x].son[k^<span class="hljs-number">1</span>]].p=y;<br>    tr[x].son[k^<span class="hljs-number">1</span>]=y,tr[y].p=x;<br>    <span class="hljs-built_in">pushup</span>(y),<span class="hljs-built_in">pushup</span>(x);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; root,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(tr[x].p!=k)&#123;<br>        <span class="hljs-type">int</span> y=tr[x].p,z=tr[y].p;<br>        <span class="hljs-keyword">if</span>(z!=k)&#123;<br>            <span class="hljs-keyword">if</span>((tr[z].son[<span class="hljs-number">1</span>]==y)^(tr[y].son[<span class="hljs-number">1</span>]==x))<span class="hljs-built_in">rotate</span>(x);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">rotate</span>(y);<br>        &#125;<br>        <span class="hljs-built_in">rotate</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!k)root=x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> p,<span class="hljs-type">int</span>&amp; root)</span></span>&#123;<br>    <span class="hljs-type">int</span> u=root,fa=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(u)&#123;<br>        <span class="hljs-keyword">if</span>(tr[u].v&lt;=tr[p].v)fa=u,u=tr[u].son[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">else</span> fa=u,u=tr[u].son[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!fa)root=p;<br>    <span class="hljs-keyword">else</span> tr[fa].son[tr[fa].v&lt;=tr[p].v]=p;<br>    tr[p].p=fa;<br>    <span class="hljs-built_in">splay</span>(root,p,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tmerge</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;p, <span class="hljs-type">int</span> &amp;root)</span><span class="hljs-comment">//启发式合并</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!p)<span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">Tmerge</span>(tr[p].son[<span class="hljs-number">0</span>], root);<br>    <span class="hljs-built_in">Tmerge</span>(tr[p].son[<span class="hljs-number">1</span>], root);<br>    tr[p].son[<span class="hljs-number">0</span>]=tr[p].son[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    tr[p].size=<span class="hljs-number">1</span>,tr[p].p=<span class="hljs-number">0</span>;<br>    tr[p].min=INF,tr[p].sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">insert</span>(p,root);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-type">int</span> ptr=<span class="hljs-built_in">get_node</span>(a[u],<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">insert</span>(ptr,root[u]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[u];~i;i=ne[i])&#123;<br>        <span class="hljs-type">int</span> j=e[i];<br>        <span class="hljs-built_in">dfs</span>(j);<br>        <span class="hljs-keyword">if</span>(tr[root[u]].size&lt;tr[root[j]].size)<span class="hljs-built_in">swap</span>(root[u],root[j]);<br>        <span class="hljs-built_in">Tmerge</span>(root[j],root[u]);<span class="hljs-comment">//启发式合并</span><br>    &#125;<br>    ans[u]=tr[root[u]].sum;<span class="hljs-comment">//splay根节点的sum就是总共的方差</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> p;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p);<br>        <span class="hljs-built_in">add</span>(p,i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,&amp;a[i]);<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//从根节点开始搜索所有下属</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>,ans[i]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>csp</tag>
      </tags>
  </entry>
  <entry>
    <title>第32次csp认证题解</title>
    <url>/2024/05/30/%E7%AC%AC32%E6%AC%A1csp%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="仓库规划">仓库规划</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">15</span>, N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> a[N][M];<br><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> line1,<span class="hljs-type">int</span> line2)</span><span class="hljs-comment">//对每一行行判断,line2是否全部大于line1</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = <span class="hljs-number">1</span>; w &lt;= m; w++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[line2][w] &lt;= a[line1][w])<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_line</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">//返回查找到的上级</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(x, i))<span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">//数据读入</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++)cin &gt;&gt; a[i][j];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">find_line</span>(i) &lt;&lt; endl;<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="因子化简">因子化简</h2>
<p>会欧拉筛基本上就秒了，还有记得数据范围</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">bool</span> not_prime[N];<br><br>vector&lt;<span class="hljs-type">int</span>&gt;prime;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LL n,k;<br>    LL result=<span class="hljs-number">1</span>,len=prime.<span class="hljs-built_in">size</span>();<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;prime[i]&lt;=n&amp;&amp;i&lt;len;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-comment">//cnt记录次方数</span><br>        <br>        <span class="hljs-keyword">while</span>(n%prime[i]==<span class="hljs-number">0</span>)<br>        &#123;<br>            cnt++;<br>            n/=prime[i];<br>        &#125; <br>        <span class="hljs-keyword">if</span>(cnt&gt;=k)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(cnt--)result*=prime[i];<br>        &#125;<br>    &#125;<br>    <br>    cout&lt;&lt;result&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> q;<br>    <br>    cin&gt;&gt;q;<br>    <br>    <span class="hljs-comment">//首先筛选出小于1e5的所有质数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=N;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!not_prime[i])prime.<span class="hljs-built_in">push_back</span>(i);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j:prime)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j*i&gt;N)<span class="hljs-keyword">break</span>;<br>            not_prime[i*j]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-keyword">while</span>(q--)<br>    <span class="hljs-built_in">solve</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="树上搜索">树上搜索</h2>
<p>一道考基础知识的题，思路并不复杂，基本功扎实就行,思路请看代码注释（以及尽可能详细了）</p>
<p>dfs 邻接表 递归</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;LL&gt;temp,wi;<span class="hljs-comment">//wi存储该点即子节点的权重和，temp存储每一点的权值</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;ls;<span class="hljs-comment">//邻接表（建树）</span><br>set&lt;<span class="hljs-type">int</span>&gt;yes,no;<span class="hljs-comment">//yes存储未被删除的点,no标记被删除的点 </span><br><br><span class="hljs-type">int</span> n,m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur)</span><span class="hljs-comment">//初始化yes与wi</span></span><br><span class="hljs-function"></span>&#123;<br>    yes.<span class="hljs-built_in">insert</span>(cur);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ls[cur])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(no.<span class="hljs-built_in">find</span>(i)!=no.<span class="hljs-built_in">end</span>())<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(i);<br>        wi[cur]+=wi[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_min</span><span class="hljs-params">(<span class="hljs-type">int</span> cur)</span><span class="hljs-comment">//寻找指定最小值 </span></span><br><span class="hljs-function"></span>&#123;<br>    LL min_data=<span class="hljs-number">1e10</span>;<br>    <span class="hljs-type">int</span> min_idx;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:yes)<br>    &#123;<br>        LL data=<span class="hljs-built_in">llabs</span>(wi[cur]-wi[i]*<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span>(data&lt;min_data)<br>        &#123;<br>            min_idx=i;<br>            min_data=data;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> min_idx;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> num,<span class="hljs-type">int</span> min_idx)</span><span class="hljs-comment">//检验num是否在min_idx的子树中 </span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(min_idx==num)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:ls[min_idx])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(no.<span class="hljs-built_in">find</span>(i)!=no.<span class="hljs-built_in">end</span>())<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(i==num)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(num,i))<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-number">0</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <br>    cin&gt;&gt;n&gt;&gt;m;<br>    <br>    temp.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">1</span>);<br>    wi.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">1</span>);<br>    ls.<span class="hljs-built_in">resize</span>(n+<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">//输入权值 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        cin&gt;&gt;temp[i];<br>    &#125;<br>    <br>    <span class="hljs-comment">//建树</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> fa;<br>        cin&gt;&gt;fa;<br>        ls[fa].<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        no.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-type">int</span> num,cur=<span class="hljs-number">1</span>;<span class="hljs-comment">//num为要处理的编号 </span><br>        cin&gt;&gt;num;<br>        <br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>        &#123;<br>            yes.<span class="hljs-built_in">clear</span>();<br>            wi=temp;<br>            <br>            <span class="hljs-built_in">dfs</span>(cur);<span class="hljs-comment">//初始化wi与yes</span><br>            <br>            <span class="hljs-keyword">if</span>(yes.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//当只剩一个元素时查找成功 </span><br>            <br>            <span class="hljs-type">int</span> min_idx=<span class="hljs-built_in">get_min</span>(cur);<span class="hljs-comment">//查找指定点 </span><br>            <br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(num,min_idx))cur=min_idx;<span class="hljs-comment">//判断所要查找的num是否在min_idx的子树中 </span><br>            <span class="hljs-keyword">else</span> no.<span class="hljs-built_in">insert</span>(min_idx);<br>            <br>            cout&lt;&lt;min_idx&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>csp</tag>
      </tags>
  </entry>
  <entry>
    <title>第33次csp认证题解</title>
    <url>/2024/05/09/%E7%AC%AC33%E6%AC%A1CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1-词频统计">1.词频统计</h2>
<p>简单题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> cnt[N];<span class="hljs-comment">//记录每个单词出现的次数</span><br><span class="hljs-type">int</span> cn[N];<span class="hljs-comment">//记录每个单词所出现的文章的个数</span><br><span class="hljs-type">int</span> flag[N]; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-type">int</span> count1,num;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<br>		cin&gt;&gt;count1;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=count1;j++)<br>		&#123;<br>			cin&gt;&gt;num;<br>			<span class="hljs-keyword">if</span>(!flag[num])<br>			&#123;<br>				cn[num]++;<br>				flag[num]=<span class="hljs-number">1</span>; <br>			&#125;<br>			cnt[num]++;<br>		&#125;<br>		<span class="hljs-built_in">memset</span>(flag,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(flag));<br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>	&#123;<br>		cout&lt;&lt;cn[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="相似度计算">相似度计算</h2>
<p>直接开set,没什么好说的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> cn,cnt;<span class="hljs-comment">//cn记录交集的单词数,cnt记录并集的单词数</span><br><span class="hljs-type">int</span> n,m; <br>string word1[N],word2[N];<br>set&lt;string&gt;bin,jiao,words1,words2;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<br>		cin&gt;&gt;word1[i];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;word1[i].<span class="hljs-built_in">length</span>();j++)<br>		&#123;<br>			<span class="hljs-keyword">if</span>(word1[i][j]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;word1[i][j]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)<br>			&#123;<br>				word1[i][j]=word1[i][j]-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>;<br>			&#125;<br>		&#125;<br>		bin.<span class="hljs-built_in">insert</span>(word1[i]);<br>		words1.<span class="hljs-built_in">insert</span>(word1[i]);<br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>	&#123;<br>		cin&gt;&gt;word2[i];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;word2[i].<span class="hljs-built_in">length</span>();j++)<br>		&#123;<br>			<span class="hljs-keyword">if</span>(word2[i][j]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;word2[i][j]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)<br>			&#123;<br>				word2[i][j]=word2[i][j]-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>;<br>			&#125;<br>		&#125;<br>		bin.<span class="hljs-built_in">insert</span>(word2[i]);<br>		words2.<span class="hljs-built_in">insert</span>(word2[i]);<br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(set&lt;string&gt;::iterator it=words2.<span class="hljs-built_in">begin</span>();it!=words2.<span class="hljs-built_in">end</span>();it++)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(words1.<span class="hljs-built_in">find</span>(*it)!=words1.<span class="hljs-built_in">end</span>())cn++;<br>	&#125;<br>	<br>	cout&lt;&lt;cn&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>&lt;&lt;bin.<span class="hljs-built_in">size</span>();<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="3-化学方程式配平">3.化学方程式配平</h2>
<p>根据题意写代码就行了，这么简单的题我当时居然没拿100分，有点气人</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bit/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gauss</span><span class="hljs-params">(<span class="hljs-type">double</span> a[][<span class="hljs-number">50</span>], <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> hang, <span class="hljs-type">int</span> lie)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt;= hang || y &gt;= lie)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 用于判断第一列是否为空</span><br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于标记找到的第一个元素不为0的行号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt; hang; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i][y] != <span class="hljs-number">0</span>)<br>        &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            idx = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">true</span>)<br>        <span class="hljs-built_in">gauss</span>(a, x, y + <span class="hljs-number">1</span>, hang, lie);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//idx不为0时，需要将这一行与第一行换位置</span><br>        <span class="hljs-keyword">if</span> (idx != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lie; i++)<br>                <span class="hljs-built_in">swap</span>(a[idx][i], a[x][i]);<br>        &#125;<br>        <span class="hljs-comment">//对下面行中所有第一项不为0的行进行减操作</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = idx + <span class="hljs-number">1</span>; i &lt; hang; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = y+<span class="hljs-number">1</span>; j &lt; lie; j++)<br>                a[i][j] -= a[i][y] / a[x][y] * a[x][j];<br>            a[i][y] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">gauss</span>(a, x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>, hang, lie);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> a[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>], cnt, q, k = <span class="hljs-number">0</span>, N = <span class="hljs-number">0</span>, flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//二维数组a模拟矩阵</span><br>    string thing;<span class="hljs-comment">//存储每一个方程式</span><br>    set &lt;string&gt; s;<span class="hljs-comment">//存储出现过的元素，并对其去重</span><br>    map&lt;string, <span class="hljs-type">int</span>&gt; b;<span class="hljs-comment">//存储某个物质中某个元素所对应的序号，即在矩阵中的行数</span><br><br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));<br><br>    cin &gt;&gt; cnt;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)<span class="hljs-comment">//创建矩阵</span><br>    &#123;<br>        cin &gt;&gt; thing;<br>        q = <span class="hljs-number">0</span>;<br>        string temp = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (q &lt; thing.<span class="hljs-built_in">length</span>())<br>        &#123;<br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">while</span> (q &lt; thing.<span class="hljs-built_in">length</span>() &amp;&amp; <span class="hljs-built_in">isalpha</span>(thing[q]))<br>            &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(thing[q]);<br>                q++;<br>            &#125;<br>            s.<span class="hljs-built_in">insert</span>(temp);<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (q &lt; thing.<span class="hljs-built_in">length</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(thing[q]))<br>            &#123;<br>                x = x * <span class="hljs-number">10</span> + thing[q] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                q++;<br>            &#125;<br><br><br>            <span class="hljs-keyword">if</span> (!b.<span class="hljs-built_in">count</span>(temp))<span class="hljs-comment">//如果没出现过，则为其编号</span><br>            &#123;<br>                b[temp] = k++;<br>            &#125;<br>            a[b[temp]][i] = x;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*for (int i = 0; i &lt; s.size(); i++)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        for (int j = 0; j &lt; cnt; j++)</span><br><span class="hljs-comment">            cout &lt;&lt; a[i][j] &lt;&lt; &#x27; &#x27;;</span><br><span class="hljs-comment">        cout &lt;&lt; endl;</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-comment">//cout &lt;&lt; &#x27;\n&#x27; &lt;&lt; &#x27;\n&#x27;;</span><br><br>    <span class="hljs-built_in">gauss</span>(a, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>(), cnt);<span class="hljs-comment">//高斯消元</span><br><br>    <span class="hljs-comment">/*for (int i = 0; i &lt; s.size(); i++)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        for (int j = 0; j &lt; cnt; j++)</span><br><span class="hljs-comment">            cout &lt;&lt; a[i][j] &lt;&lt; &#x27; &#x27;;</span><br><span class="hljs-comment">        cout &lt;&lt; endl;</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[i][j] != <span class="hljs-number">0</span>)<br>            &#123;<br>                N++;<br>                flag = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (N &lt; cnt)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Y&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;N&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--)<br>        <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="4-十滴水">4.十滴水</h2>
<p>关心水滴的坐标大小关系，并不关心其具体值是多少。所以，直接用set 存下所有的坐标，每次用 lowerbound 查找目标水滴，然后再将其左右两端进行更新。如果有多个待删水滴，则使用一个优先队列，按照下标排序即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//题目大体思路：用一个结构体来存储有水滴的格子的序号跟水滴数</span><br><span class="hljs-comment">//用set存储该结构体，之后每进行一次操作便将操作的结点在set中删除，并依次向左和向右执行操作</span><br><span class="hljs-comment">//在考虑哪些水滴会炸裂时，用优先队列存储水滴数大于等于5的点，方便每次都是最左边的点先裂开，且能够对所有的点进行处理，不会遗漏</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>	<span class="hljs-type">int</span> x, w;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node&amp; a)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x &lt; a.x;<br>	&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> node&amp; a)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x == a.x &amp;&amp; w == a.w;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> c, m, n;<br>	cin &gt;&gt; c &gt;&gt; m &gt;&gt; n;<br><br>	set&lt;node&gt;s;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>	&#123;<br>		<span class="hljs-type">int</span> x, w;<br>		cin &gt;&gt; x &gt;&gt; w;<br><br>		s.<span class="hljs-built_in">insert</span>(&#123; x,w &#125;);<br><br>	&#125;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		<span class="hljs-type">int</span> p;<br>		cin &gt;&gt; p;<br><br>		<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">lower_bound</span>(&#123; p,<span class="hljs-number">0</span> &#125;);<span class="hljs-comment">//找到要裂开的点</span><br>		<span class="hljs-keyword">auto</span> temp = *it;<br>		s.<span class="hljs-built_in">erase</span>(it);<br>		temp.w++;<br>		s.<span class="hljs-built_in">insert</span>(temp);<br><br>		set&lt;<span class="hljs-type">int</span>&gt;ans;<span class="hljs-comment">//用于存储要裂开的点</span><br><br>		<span class="hljs-keyword">if</span> (temp.w &gt;= <span class="hljs-number">5</span>)ans.<span class="hljs-built_in">insert</span>(temp.x);<br><br>		<span class="hljs-keyword">while</span> (!ans.<span class="hljs-built_in">empty</span>())<br>		&#123;<br>			<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">lower_bound</span>(&#123;*ans.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">0</span>&#125;);<br>			ans.<span class="hljs-built_in">erase</span>(ans.<span class="hljs-built_in">begin</span>());<br>			<span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">begin</span>())<br>			&#123;<br>				<span class="hljs-keyword">auto</span> it1 = it ;<br>				it1--;<br>				<span class="hljs-keyword">auto</span> temp = *it1;<br>				s.<span class="hljs-built_in">erase</span>(it1);<br>				temp.w++;<br>				s.<span class="hljs-built_in">insert</span>(temp);<br>				<span class="hljs-keyword">if</span> (temp.w &gt;= <span class="hljs-number">5</span>)ans.<span class="hljs-built_in">insert</span>(temp.x);<br>			&#125;<br>			<span class="hljs-keyword">auto</span> it2 = it;<br>			it2++;<br>			<span class="hljs-keyword">if</span> (it2 != s.<span class="hljs-built_in">end</span>())<br>			&#123;<br>				<span class="hljs-keyword">auto</span> temp = *it2;<br>				s.<span class="hljs-built_in">erase</span>(it2);<br>				temp.w++;<br>				s.<span class="hljs-built_in">insert</span>(temp);<br>				<span class="hljs-keyword">if</span> (temp.w &gt;= <span class="hljs-number">5</span>)ans.<span class="hljs-built_in">insert</span>(temp.x);<br>			&#125;<br>			s.<span class="hljs-built_in">erase</span>(it);<br>		&#125;<br>		cout &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>csp</tag>
      </tags>
  </entry>
  <entry>
    <title>一些小tricks</title>
    <url>/2024/05/09/%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<h2 id="结构体运算重定向">结构体运算重定向</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>	<span class="hljs-type">int</span> x, w;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node&amp; a)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x &lt; a.x;<br>	&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> node&amp; a)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x == a.x &amp;&amp; w == a.w;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>上式重定向了小于和等于运算符</p>
<h2 id="筛选素数">筛选素数</h2>
<h3 id="埃式筛">埃式筛</h3>
<p>时间复杂度：nlog(n)</p>
<p>埃式筛就是筛选n以内的素数，从小到大，对每个素数的倍数进行剔除，最后保留下来的就是素数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">bool</span> not_prime[N];<br><br>vector&lt;<span class="hljs-type">int</span>&gt;prime;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<span class="hljs-comment">//所要筛选的素数的范围</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i*i;j&lt;=n;j+=i)not_prime[j]=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>       <span class="hljs-keyword">if</span>(!not_prime[i])prime.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="欧拉筛">欧拉筛</h3>
<p>时间复杂度： O(n)</p>
<p>算法思路：每个合数都由其最小质因子筛选出来，这样能够保证筛选的线性，每个合数只被筛选一次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">bool</span> not_prime[N];<br><br>vector&lt;<span class="hljs-type">int</span>&gt;prime;<br><br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!not_prime[i])prime.<span class="hljs-built_in">push_back</span>(i);<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> j:prime)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j*i&gt;n)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//这一步不能遗忘</span><br>            not_prime[j*i]=<span class="hljs-literal">true</span>;<span class="hljs-comment">//这时满足j为j*i的最小质因子</span><br>            <br>            <span class="hljs-keyword">if</span>(i%j==<span class="hljs-number">0</span>)<span class="hljs-keyword">break</span>;<span class="hljs-comment">//当j为i的最小质因子时，若继续向后遍历质数，则那时的j*i不满足以j为最小质因子，会造成重复筛选(虽然对结果没影响）</span><br>        &#125;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>视频画质提高免费软件分享</title>
    <url>/2025/05/18/%E8%A7%86%E9%A2%91%E7%94%BB%E8%B4%A8%E6%8F%90%E9%AB%98%E5%85%8D%E8%B4%B9%E8%BD%AF%E4%BB%B6%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>资源来自于b站up主<strong>资源汇社区</strong></p>
<p>详细操作视频可以见<a href="https://www.bilibili.com/video/BV1Fu1gYmEGV/?share_source=copy_web&amp;vd_source=29b5e748cad44c258157263ce3619eee">b站视频</a></p>
<p>破解步骤如下：</p>
<p>首先点击 <a href="https://pan.xunlei.com/s/VOADGKMhVkjQ5uO3uhOJ3XFfA1?pwd=6u89#">这里</a> 下载软件包，解压密码是zyhsq</p>
<p>在解压完成之后，再解压里面的另一个压缩包，如下图：<br>
<img src="https://pic1.imgdb.cn/item/6828cb8958cb8da5c8f9558a.png" alt=""></p>
<p>进入解压完成后的文件夹,双击如下图框选的.exe文件<br>
<img src="https://pic1.imgdb.cn/item/6828cbf058cb8da5c8f955a3.png" alt=""></p>
<p>之后默认一直点下去安装就行。</p>
<p>安装完成后将下图所示的<code>Activator.exe</code>文件复制到软件的安装目录，双击运行。</p>
<p>在跳出来的弹窗中，勾选如下选项：<br>
<img src="https://pic1.imgdb.cn/item/6828ccb458cb8da5c8f955bb.png" alt=""></p>
<p>EMail or Name中随便填，完成后点击<code>Activate</code>，完成激活。</p>
<p>e.g:激活后<strong>不要</strong>更新qwq</p>
]]></content>
      <categories>
        <category>好用软件</category>
      </categories>
      <tags>
        <tag>基础工具</tag>
        <tag>pr</tag>
      </tags>
  </entry>
</search>
