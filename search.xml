<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一些日常的碎碎念</title>
    <url>/2024/04/18/diary/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="15aab802dac082328416a9fcc39b22e6e98e4550983a7ac668fd7d9a59823c10">a6c09174f42c2996d998264a07e1ffbfe749e3aa27c4bdaa2d3499a4226b96c45d4ceb88c94a9428bd5cdc02d9e1f43d3e3bd59d8074f70df763b9bdf99a6350281e01cfe176218a324fe2cb30bdbf547e9e494844e12af53957851ac901bfcf3022fcaaad5ee458ac385fbd9713cb932da8007d6fd91c60250e6ebcbd5a73c74f3fd75dfd57421940e405addc082d5e9eae9af8c4f1f9e19907f6cc1e61eb0a778c5a31392fce3041d0b877577daaa844e7e286e400bc66826d1acd13693d3fca8b34f79b3ce70b08841c13f099790421d5e19dc025017650c43dd4d96879631188c25fa21b867579f55bb33ed5fdd20fdcda9d93e35f8c359d8c8e20a8c15a0ca77673ef2169ca48fa0ebd7111466c21d6962c3b52775542d89121dbc371312d82ef5cdeca10b25f9d9b476e5cb874905b2acf2c3d716529cc85b7e725951b8d9d4bb1ea30dea4a7556b06f451a3b6390d9eef145ae4c9eff54cd97f428238b007880c60539efd69dd8886dc18ac4c7a92e0a8e75a9745e8613e7881e73140b267710e8c4b6ffda97145467c056d3d39b1c3b537319fe250b4dbe9b8e7ad5c8529ae8adaa8bdbfbd7d94bbb1e7cc1dc24b0c4062e9915e06a74f4cf14ce9b0088f6cad0c7610896ec10bcdd2a0d09d50c498f9a284c89dbd7df7f14c54b3710af65aa063e901fa856307be6c8e4eedc9633ffa6e169541440017e264c353ff7f69c770f2cc7fb4dd87b0028a8d53be6524c53a49394d2fcedd2d19a60ff3a95a33c9cf20f0946c5226e5ceece153be21ecf4b9594315f59f2380bb5a495dc449c939cb1b8a54a9d94d76bc77a80ec7cd6d4a846e5d67602ea4a0c0389c8cc05cd130fd38a2e69eab72beb3b9625daf3ba783aef06ea1a9e7814a2650c5bd7b00fb715bec1e62024a4934ac73a295ee700b4236870b11d430c82666a29e450f263d0dead3fe751cdd23a14f3893c235e6c3060dda53e0b87a6496504ca4de35a3694c62a1252a2050dfa488ca25b21b039771d7fbf2d47168b1864bdedbdb162bd7c81686950dcff7be382a35ad576997ea37732644d31696f02d25d5fe2cb0d787f8cf4bfbc930c7fa651b163149455f937322002a33bbd2357f19db68fc51c7907392e29afaafea2b9bfb4977cdea5bf2ed949a187061d1d243b6952f6aad72384012146d243c42d8becd5ceb90bea89053f0129c4b1490821d317b335f35976e48d404f8af0891304b1f59ee4359a6538941b1e9b8b2be2bc57a6ea7a9050b8949ec507447cac5aeeb3f786ddb5a0efe11a6e3aadd8a51ed802bdb0661155b5785c89040f5d2dc86b10b1da6af9b261313678a0f20c4251d09f39ffad610de88f692ca8134acbf372ff1f852062c86fe09f281037cf29809c1c0cd2f0399598f3f1082a12ad3b7b793207876f9beb737b3b1458da81f34cb33a2becbe75c8062aae8d02f187e7a63b3f84c394d7cd80d2e55bfc6a56bd8b1b7463c6dbd1b8defe8155144dcd975dae14be9c49faae6b19e668af499466bf8a1f39ed1c697c3ff5696cf483046ac7d7195dcde8c310fbaf76ebfe6455decc5c0f94f5afd093eba353a74183d89aebed427413b70773b87b19bf3a41041acde12106a870dba00bc09dbc5232536bfb2d778f7ec3383eefd8b85be430433b80fa3e63cb40514cb30c9ec591bc5086716c6775b95cdb87f7318ecf0bb26ff13286409015686283f1a43ae3706bf088f0e5633c1ee9d814ede77f182c1d739cee10317bf375143b036c0e2f5d3aa106cc84c23ab1507568d947a6479b6f485d020bfcc84a567ec2bf4948ef2c7dab9730db79884a72dc3de70c34f656142ccef5fff975d90ea2a637d1913d47f73879d1f14492a7d557071b0cbe7be749cd9b9d53855f7d83e58c09d6e26622fd2c0d8aedd1db93118a18faa89ff87a9bae7b9dc6d0f5dc9a109a7eb22f47af4aee28873fe47e66d29fee344286d9cb2da6d577735bf12e2de2ac652232c2db78602b65a2a52762a70494eb9544a317bdcfc6156ea8540cc06e4f89f69fd71c1074606f1fe2642eff4df26cee1cc91a9447fba558255a91d040f06264614ab5f63da436b20523c597041d54da6415fcf3f7fcc06fef4c817b7198041b1530d2c5fdb6bcc126839664a0f5fb0bbd50b74e71740a3a1e07d131f9919999ad5d153f41e21706ebcd87d01efb351d69f7babee1c65b6e1d4308999004aa42b5dabe2847305ab7020f7198967c6abf58bcad5cf63908b28cf09541c02c371902aa5ff4a5448662deacaa35003985243cd49566ae82ac9f5b17e7a3609a4f3b0fa88d03cb382377a6c7cfed33ff08b23e9123a600bbfa3b155b953eef5addc4c0b5482f261186abda03ed66634db73d4d0acabfd551ed5d022ae74498400432ede5609139b2b80f8721282b63a9dd738389e70db3e1003c3aa1c236206f3c9983fd3217bd14e4947672a71a1d938b7925463b4dcd69833831114898587b1c3272bd114a60645ee619a0e7ff7a70af7aa40b21aa2ee91010d3ffd9c55ba7a21a12e2d1a02c2e697d6c3fcec3baaaa74a22b15b9be83e77eba51d4a557bfa87e1e63fe8be6aabbffc87a2f7334c545b556acdab5769fd6e2d9e4fa3c10e04658cb229b91de7866624bce4de42d1be74ef1df7c94d01e0f94d8d113547bd51e4fcf58f502b3c959296670dbd91b85a6ad22b6dc3cc9a4fad192364b09b05b72fbcbedf5b2cf5f6dd04418ac3fd976a19d76a6b95dc89512ad9dc2b98b487dd878af56be03e302a973bb108c820d1c395b99b165b7403c46d44d639e69d8401f65f1ec35d5f4781f17c450b1811566b05d2f9d1335b94e47974ebf0257bb770e22dbefb14d103d035c0ad68966657c2710bebaf59b1298bf840d7999876e7ddacfb5689b81655510440eb8acb90eaf4b60f9160ef2fe6c48b429ce32878dc70b43a9363553a73459e638c6c1d11b65b9a6abdf0236b3be32dc9eb3d86f7fe73644e13ad8e5c3011fc7a26bc37479353fd7454627acc9a11c7e226446fd2033fc9cc626ce792a41da7d3411de8ad841bd8422c24cb384f5c90d7b72d3e446807af10a29e23c3b9903175b4c18401667fea961379992b8736ee1e3a779f70a44c4c57ed592ccd22167a23a52c63e6e790716b1037c051303abcd015d865c69a36d719c2ba4b152a86235569ae5d6f000abbef569328aca958134fbdb775f6cd1c6ac605aee4058b2202d11644d771c4a06bed8e7fe4b2884bad6ee380de623833083ade912639f10812db4baaf6ab1b51a5402f4e0de5b80cfd7ec60493b56cd4f9862894f871168b94d8d3b0af372b7bb6855b6cfe90d8ed946466a2bbc3c89e36ba03fbe95a90597f0776defba6de5c6dd3331c145b9680d6f306459dd4ef2cba7293de31a713cc37c28533e058631673fd9bc7845464df73167245d66ba9fc962fa499b566791fdac5abbd92f1db202d7b73ffbf789637f91e20c2e6fb4034a0f748dd118ee9f27712ebdb97f59d8a6674fe02050c2cc81e27d9c54f9a61088fe4d69c67315c3723cbe984c891403146d7432aced4fdd7486fa6afb4f53896d03d13da5805bb02c33865eac3d03c6e62bb69c752939f302967752d42fa5d7f34b07bad7271a3053dd848e5616fe0429ce49c1dc312ecb45fd4a537b9c1f12aae58482e7384e75b9e1ebd167f97bdfdf704f15feb00861cafb092b3a7217dc0c77b3ee26d51d5218e98e837425dd3e2f304f66ce98d41356983a56a68e8bf1ca8f863bec482a75f2a1f31ba5cc3ae2ed91f675dea11234907958064c30e0c6d857a6625c9884116dd4a3159c806a52e06419bb7873df1907d9cb1be9f19037f636d124a40331bd48f7abccfe96f141bdf7d01051f5ec32a320419bc9959260cac4ef727ab1f37dba99090db3f7f0f4fa7c1b69163aea5e9dd445912d61e5a36ff58d847d00ff34f3d8e7a1e27231af23660f1aad1e14c42b383a46c530dead5f15f232ea88a148aa33262497d5e4bb529194ab7532c2e9d6db1a8ce7afd9e38f44a222aa53ac6b0fe650c1638c73812359edd2cf953f7fe1ce576f73fe04da801d6e4a25798347bcb8d45e643bd9d6139a3f92a84b819a8f0db887ba1339ea1ef1ba572b77ae59d46b4e9c8695ee2a2c79bcaaa07cdf360c48eb001be13edb4f01fef519cf4cb5e924be55bacf5b94ec2c2caf9c0645e19e32f244ee38e34e6b315a6f9a875d6f7b9b391882f8844f281218de766e94494d1f179e7eb44f364ef029c7c1171a1d0b23a075387198ec9ffb44674d49aa2c2f16ff817cfea4d9509d478c1b6169247dde3a1a93fc570b2173764ab8cff6f03443201ee974d3f190559b2f3600f06a3bd55613d52d4284263c208055d1c5e39fb68bb1ac695af90ae03b30dd76b85b979702e752ebf92317c87c88dbff04be359850a200d1839310977375ff96e80845bdbf646793b871f73ecb550bb43dfcfa29eb1d383b329351239fcf4610de499a2892ebaa1087dc991dea91dab5a19095631afa0d379ac638c92fde941dc6352c5a01da59e60ba62bde000ba662bf25f56283113d0a3f50f4e8f01568a71573dc355f70c5e49d3202cb97f3147865de3ac7787cb4d787d48c909344d62a9f5a2ff7f099652eb61365babd82e8db77ee7d540025355ff1d66da7f3d1aa3393c730f56073d956b46dcc1ee2e5f883d0ba8ace8815e47de9e254eb23473185432ad63716a23a78780321675becca6bebb1dc3372d35e954bfc048b79d88e765afa9f47e45b31ac3266c676867e42e9d877a24ce21e409c72651c359233f763cd2215a04c8cef7f3ffe65af2b76f3cf1df39321a526221ea658c97256b1f84e86f38d3eca7b422e1da7106c657ca79015cdd5b1e3b474058b50ee0946e56524f103edd35c92c972dcf2114b0a53f48f61d65d73566afc3d8b990ca6ff2a962a2bc8f1caccacde15676b22ac93b52b84d1c74b179e260f618ce230526e01c4fdfb438edeb73dc361f11e54d23232d667c6f2852805bc0eaac9536aa06391a3d90a152d6bc07ce6e9773910a03dff61f3be737bb7de1b4c5a57860160477ec5ee40e396a56a415195b635d222c708c484676df05ec9d32d4e9d5110814895b9d341c4dc95b2ab4edbbeae4d39b317543f4d598961801b9465583c4fd6f0ede0a4ff660f27f4726a5837d7c88a516243bbefc71e0a0444cc0cf93bc54cd0866e6edc8e453ae6c37917765435e6e17911356dc219c7922c323ced1cfb32df4c75f5b0cf74b6b4af2a533926ba1d82c108bbcb58fff238d8c9cb17e4b0c7cef79498846e69bcab80b6736b5336f76aa04fd488105437c6fa9b1b367275d7121d585b9870b8c5f651e93155ed97b32ba01e55dc32d9f7cc388b7e664e58a06159ea9db9726aae43af5dc330610cf858599bec542fb844654af486771325321ca3f217044c8dffd13a31144c85dc9f8a305c50f8ad9c197b148700fdd37ccd0a4e71d97808d8bb2c6bc9a57e25f948f297054f47bb607aeeeb466021325249da627aab23a2c14ddb739ca0612d31567ac27ad88747044adbfe7753777fb7acb6eb7da853e6dff3f45ec42fe5b96b8857c7ab28945495ba4f87144d4860beb65e2425ed2fdbda352e070b0ce9169a308c052a15c5a9d264543daf290f05f5f276768b10b6ab4df1bbadb617f7be5ff67b4f6378ee6d46827b70b363e7681afc1805ed484d9d80c2d0b2eecf2bf9b99334529af4730cd7f1716de0a6e2799a04e368d1c33af20af80efbedf9b615f9be08e00fcdc68c57c003b2437d28dcc945b7645330a37a1ff9dfee9420f350b9202a1e6552de8593638139fadd85ab895cca84ddf9d9d5d0a570841665ec52f6ee0a56a3c83c858118bb9c9e93418e2204b1d68832e7323bad43eb421d17359ec850ff467251492e0d3f5c440a32b97b5e72215feeb291662454b1566da0610de6ff3d6a13102b2edafbfea292dc60000990e3b3d982eabd8309e60ec4375fd03b8834aa9f87dff98494905f1973168cae14cc7ca07d2d42dcd364bd33a03e5d3fcd2d8b82dc4ea3291851ef7de96867b245e4d4dfc8bb9d9d5aa1a95d0c14ca03d7b88d6cf4108459bd4ff72323e425c08054889ba808ca7f2631c7a3ed02b5f452d66863a53bedba01a6d387cfcc8efae964763b52b41f1357b7b92bdd8082e309577bd6e9c16579de1b4930d78c39b7d3aa191ecf16197dd6fde664f8c4969a9448f8d6158b94104cbe88f200723165991e0c73de3b1526baa3377a1b818ea9865087fbd33dd5608b3a83ad97ffedd6f3b5cf46bfd71aa2b8cfee9c3ad0f19bb04a5e9ea4bd7c2603b4dabcc8022e9ed41574ca69cd9fbea33016791068ad6d3a5c291df99574bd59c6527e5a34e9db27ce1c40191c37ae8f4e9939b23f7bbbbe758b2f814cfe9970c8cc9ffc76724eb6bf3913190884b33670d9b6c6eaca8ba81f9812f6b5acf49fb563aa7c06ca4cab1d285bcb98ab3b498da168dfc9d9f52e6008a8cd5743cd7ac0281c890500b2834e679412d73ccaa51a7bd77a5559fd2784d606f878b62e6ed53f4a93ff7dfec0719636c0dc31a7f82bd9b10196b6524901e270db70795b40053edcb5c009175e3dcae8b10641386c1381f3a0746f94bc700ce7c124b109748182663cbd662db62d806bbc52799e1c679aa23ca66f225a3d81dd83e036efc6fe67154ccb7afb38f02b8a0c68979d574c3936450efedd8fc41580344984384bbdec4d464f5a6d80239d85de7551ae8b28d5a826a42a135965d6fa19bc32ade8561b507c737fe8edee9c3b6e7a4e58eae009be6cc993e5cf56eb0a026096257bf6c73e5a66abfb8a938840e8452cd6af5b54f9e534dffbc570fde8d84fb9a591fc9a91dcd07345345143260040337db0836429ce9bd6964955e47092b1e4f2ce6bbda342b19f26c2ef4079250e0ccf5a9cd533d28c987616564f5d72a834ba45fd6f84be1dd6222cffdc1e33ca7506cdd135f91eb1c9cac594d694f209749e8cc3494426c2611b21c0ccefe59da90402be41c8f93b8ced714de7f92237f306392e8f306ab0d4502b29506dbb6bb4ab192cf6a9aa712d5f0ba968cca6326b24cb506a3604bdb45610645ee236a90d07bcbdf046f1fdc83adcd1c7c0099e8b501af18ff58a582e3f8c75bce309b9af49da3cbfaaaf1fb1539240578f111b95a7266c3c6b3eb645cef37b50e09c6573ddbf3928ca5f841319e5e5bd6fa55b0a332f6b09952932a4dce0ea9e1993ddffb28f58d9b33d02357d9a89bef33d387a27937b0263cf884d2dcd9f3bc69dc7dd7ffa3c893f76b8a7aef5674fc40b9922395842484a629fbc8b89fd31136b5d1451d9c69e8bb77245466602a88f75e343c4e779f054c412957a80b62b59acd4f74fac7f2657430c8dffc361c052c770bf6699e359da01d2bb0755bf0b66be2f6a95c4c48236260d1afaaa09338fa9c24e1fe9caa06fa3523fb3e3df1896c75c16fb313c6265ff5597816fe85bcc1cfac8eb069363a3ed8ffc7aeabc1a73528f2fa058e84db1ae47b95f3c54518a342cfe0a59c4aac30f92b545f7d774c5bdecbf618652e48fbea5b677de44d93b678be8b4ab1612e3427e9b1424f628efdc96bac42d8b901f8627afdd81e71bc65b4dad9a0e06cdbc5b96d51393f1e3c5d2681a6c138e4500e0b2383cc50026ab4e352cebe7a3936b36808b29a62f23d1ff489dffc96a4f17a795a1ec6375c8ad177f19db5a7d6ff44f51eec2ba0d99f0a50274cb0e5493914245380d49a012567370510a004ccd43ac2c387628dee9c1feea8916a227a48cd3b91dd46c7f40b975acecc83f500f6c65860562857979c16365d29299ea1ddf6802f39236225e1e2241747587ad57f96458ed17ff9acdf7f866c5fe77c752f1cac23fbb2eeec7bbcccb7a28bcd410c2158a68cc99a4879d5b1cb845c95de9fa9399ae51d41c8c63aef84758249eb284f87c1d0694b7936d20ea300b53e50a08f80cddee5852e5c4314c373393b54b94fea6237753cbe531f65bcfdc56764c068329c8bba6f7feeb94c998a8f2d0f915d7b8eccfdd5115cf7fc34cde87c4d6af8c149abaeaea77038584909aadaf0e54b106f5371d36b68ab686f8aa8387b3932ddc6eb6a1e3af55005f7eadece8978182d4b88cdf15548f726d7e96e3a5b6dd711f62c369abae412bc4e52bc5ccc6ec749304cd09b87f1ebf4cf356309ceea176dd64d6f12e1ce09be6d6d295125570108253aec9e2819398b7f8bbd81e9104ed1a07c83a23422c9e8d2e84df52b0a995b12e7ecabc9ba4cc894612ea9bd6ce40af0551ba29d34a8bba016974688b5113c8764386aa1cb9a8fec52c855f866467fe823fa7d1e5a4ba67ff2ec81be06a2a9c466bf70612db01d2e7a645a8c547103bc9b6b9028ac536daec4f441a5212b12226d9a7b6945ecf5e73a9c6ffa06ee2db4802a55ff44af6c62ae1014417f44a5dad76703abeb82a5d8e7e5a37f5b2a8158677224d55c965c367ad3d3b705812ae931899377839e65e6425bdf7a829ea4029aa02b973ae64d4bb928e7e1591754c16ae491a46c978b4e82ff382bffb9ad342824d37719b0cff5581b7ad9760e5ed1a3b93aefa3d1c120899d89a4f7845bf906fd8aeb93bc459eee522ba3ef6f5a80952177b60e570d52ae784a635a3aa984abde22a3db1d0a3ecea818f8c59374871769d94dbaff65d1e03726e18ad6644cf4c7a89a8884227424bbbd70ed119e10b9ed1dbb38c305e588afa0c418c1cf49256aa4ab7c6406dc822cd6313f8ed5002efbb8c74f6c3b492291a831c3eca41e894db00a8affbbb95d58071720186f1ffc6dbb6a85145f38d86e104ae29cf0f57523667ac8420bcb07daa1c0ed5c205c887bc44c89802634e00bc9ec0584b9ccd9f05d8151bdf1a101f025a8844e0b121b6f4fd326d815d00d19c548f4908ae66c1feb2461f3221ffd4eca3054734cb0667c3ef46d5dda9540f396ae942979e27b9817df94df1bd61660a7de4b1058d055465b7289487191e8e8bb4b1cecb9fa8965f830d7eb00f8f5f1149ee4062ed092efd3bedded4939adf5780b737059393fdef60aeaa11af066e177cc8738fc4873d6e41009aac5a30fcfe73869c41c47d41e16dae9e6b3f8269aaafbd065903c100250f64cec3380c21d8d1481efae8c7f3ae8fd22e16aeaf4aa23184bc1be8a286b652ad4ea52458fd9a77cb51795e7d16f2baab427fdf3653580c0a4baf9db272f2714b6937171ddca9cbc504e0ee8fe462b50c8fbf556f8a76df208c2d944166f5dc6d20fd0ea61c099b525cbdf290308d30188dabe945a90ee5d6e586d18aa643e0d9129f95c0c12acfd3975525ee836e50fc2327030c4d37f24cd1a7db982b6d8c38e329fa8db769f3b33ef225b8980aa46404139ef7958064f2fff2375fa2de4d808dbe9263a801c3b9ffd069ac6619ac9fbc35af4baab4475d75c7dce32c5abcdf2c46e6308b57e92347a55304373e3223b863f28f5d987e541eb94059381f0957a65ab45ac8dbdf81ca514883a97a333c0ea1cb56257b30262b7ab07244fbfc44630d8b18217cf1e7f0042dc6a0336925b7e56ef06cace945922c590aee9b166f931d77a0a3d22d270e2f856bff07f5725d6c3480266454569172f9747b875e94f08a9d3b67d511597f9918f5d9d07a497e2f3c3dc726212af3986249ec04dd700ad0d1434d7e50b530c351040b1cce913a4ae17eae502ae1da5f69b2fc26dcc7ecdf9db95d16c120992346a10590e5cca3981dd4682610b01b3379399d857b7d2faa8bf0a9316fca49f492fdcd5d733bd9736a99d1bbecb45929df1a1c2faf525831d132c7c9e3647b7441f9cd0131b3fc010a36adc4ec56bab9af8810972205784484471abb2691d0a475e81c7d98ee84b125b18c468bb2e71f77b77f93df768f2765dbc9cb719016410b505508111b3594eda3745a1902ad87278e5c0ec8222cc5a4d4a5f0a597c54cd47c04c90ba22924600ba0ffa6cacb6b6426d1fba769f443266a48fce294fe0ca74804e580913b99ac0c3fae37cfd6075a9dbe631735ec190eb04f95234a0cee33318bed1052790142756eecc90d006d682dcf74806432eca19f90a368a98a9f0920d104db1ccf92de9dcacb109c4e0e79f786b4b94fdbb2b9fe7cddf9b28393c3e01d3aaa100ac815bff8d184063df7f23b4eef4bc775eec7ac75bb72740f49b7485c079311aadff12909def3ef6cb5e99321547fd69672f1ac2acecf8ceb9d884ee7686b26cd83e94be50281809b7f8930e0a5be153f6737a8e64aa5838452a7bea9243a6d64001788c5d50d6c9dbb71cafee42f5a1952d944c03ef4adb4fa28d178abd4a776bb6ea32aa3bcd8cfc494671f3c276ce3fb22ef18f6ab028031a813cfcb95a4d559c14cc181416beee12deee5e6ae4254d1553614789db44de21505c024f1ac1c116d6ea121b92ee887c0411bbaa7a9472bbf7f8fbb2b76ba03388042a1569caf9ebfd3f5c66a9e91699706aab18b17239975431456db4594f91d295b8af1a33f498989a45ef453358ffb8b65a89029cecdd55c947edff28f2e5db067695b47419617b23ad11ddefd0ea6e4cef2fd4d3676e2f11e1ae3b0340e0d4b444617002a560daa35bffb405697048b9adf82997f76174c20f68a484790a3e08b70d53358f0bff2f4de440fa0c0bb47961e93d5ca2ecd7dc0a92b6c383b738ea04fb338095c3c3c1a518a441a279e01c90104871534553905b268468cee32b5509bf83b2539ad0e7c7e6ff4f54a3da99f5e2f6e7f2d1173f1c66e8dced45e11ab32aeb0e555a0a542c013b185bbc15a8d4dc9f0d1be0763bd48d95b1adde2f0ec74cdca7bb8e9f93b9b265e11e7eb217cfab769de16dc2f54558e7a012149425ef0f978d5daeab622b53f986c4a822a6d57ffd41e1c571f16119ce602e12aea0773a6d7314e96df86435a315991406fe49b155f47b1b6b65b26ebe2243ac6fcf5e3fb904a5d2efbfc621ab1149ec2e2a47ceb05cd1e70da55196c36b46930b9c36dbed8c0b3d4dd3cd06512df26419f51b7faacb95c776649a5bfdd1b4cbfafc608a92176b6fc00012c3088b172d0fb0b6f9c78e3baf409d2fb15df2eb93cf1b92ccf1d484dc6905ad51a6d3df6a1b64db1292f9e541f558472eb0df40ac1a5cb446d92b4bcbf73e37a419b79b1c92768a89b506c874674b252ad42f5d985fb3bb9191ee0503d85cb1fe8025307a527125a2a767a5522b8e2e9f6f8833a3d60ec6c118c998b0ff7e804f27cdeed0340b3af134998bc03cbac3ec53cb8e627837c0b117be4db3c9e19d7469fb5c2f59734a64e674b2b39380c949a21643116d910faae55ab550639009348db6a737e30877b2463565ff40c2b68d57a78d2fe2d409c6ffbbc6eb9b27c9cbdc15bf884b387da5f479ef44bcb2073b9f57124f841eff6e620e9658f9f74f4a14081221c84360e354732e4fc0ed17a53c39aaf800744aecb66e308a484bbb0cdfad91ce9685d41f54196b6e2edfc30c08ea5bd9df0a2acdc9453dc1c8d0c40481721825669d7e63bde052e0b90dbfa1086e9818d795b21253facee32de87be87270b57b776cf8df57c80662a199e0d95713f84d7be6b91f9b46ace775d134264ccfbeb4fec6d6e4ce0803a8399192d664f785d71dd521d82d90d87c249fed9af642f82adc92586134ae9c5f001aaba047e1002e7149243a9c0f04ccdd3c10694db58f13c8553ad004c75cfe0ba678139325db04035c7a8e1c5ef2ad3322fb01184259b1ece1fd43556f1d4c3c7de2a44f6239c5eb020c90959548a07f8252e90e0f225b70b9c4c2d1c9ada25b46dd39096ffcaf946cfccde46b9aceb423e25011d36b3261916341082c5d8f8ac0c630377cfdcd5a721c514541ff2541e4977981f3cc64ea004abf36d819ec7e4a1f2fdb887b3cc23d102c46369fae38ef71119bf5d3421ed863990873de4c579df3aa65849df618269357ef89dab3da2a8f04effecd07f94aa155b3f197a3d1ff44e0f5f40c152fe21ddd482c1971ce5951d9373b107cdfbb23abea938cd721ac45b83f5a82abfdfe99818a765c0c139be3b03fdb4dd24e1a5ee8ef0bb01dc610d43481b7d4373a130e0c59367b104d3238df59b8ac5a4c10ab48eb9b899b55597c105a8b1988c25012c9ae4079fdd39ac55e1b93ddcc4eaa463a3ac1ae8fe93d4d2cfc73c001dc69e01157cb52dbb7d1aafce6d4c8f90aa2b194bd3c6511a69faa508ea9bc9353c21752f99b3b9342159d285baac5f010a92ccec8bbf979798b9b93f67ad8a409b3050daedd3cce6c0153d4e8829b1279d1c5fad6f73228da51847090db743dc982118374864d490a52a94c015c59a01d23c8a263539690510ce9bd5c325ece3b0983394a80b8870aa35aaf33dde4725a7301676f8b5f66eedc79d43c3cbd31e521ac9eb725e7e4db48711aaf796b3c2c6577b58cdd2f1ff7f1037130e64a6ced70960c5dce7fbb641213a3cdc2c424df5d6252e8b0d1209d693d2c04431b4ac8035e9506f46066539b99d03f90b222ea5e48726b4912534fa634ef504574015e6563fa543d563c872b9f24aa46479574297e2ca4e3d1b3ab18ec40173dea3df732d70703d4b90f1d24affb1ffc9125a45ca48027b96b2af27ce1351b05dfa11933106905640f7c5ead6e517baf528efd5aaed50ad1dc6ab570b06383abd19e79320cd70b657656dbba8a9358faeb12e1fb07fd45f98bab1db41d676d88b5938aac382feba0e2e50546274611ea29a201afce2869ffc1c672a6a64ab67f6cc9f389087fcc9692383917d160b37a39b47e206c6ccb610d493e586a97c606a50462984cccd0c3b87351db640244c5d6ca4b66edb493c8acb21df0d7e37caa464427b6fc3b3d02f09685ab31f7b0a08fcb149a282cad0351ab45bcde3e3dbd594d805a15706a3d01eb12e7a3873b44991ee2ce576c26b4f7db6bb6dff4464083c21075d0a3c08a131961733c9cd067887501e8bbcbba1a8f880bae5ad230570994a4b3a919ce3f2aaa9e3091e1b9c0afbab9fdcdedff3f149549da3e8f8278a83b6e2fca104b897e65bf43165fd1f8e6cef19efc8414674f9ad91baf64502477265a40ff934aa1ac1ce5e463a31c8ec71ba21849e861f4f2651e2165d16fcff970a53219d718b5fd9d7e422b85396c50cb49277c8e69bee031175bb796ca10a4f4635e5273726a3ce734fb45d7795c87850236c499e480f1c33698cca86f991f8e0c03b4ad40a09d28de09588c6a36867251fe181456b727ae5a86dc91229b9db483eb0cbdf6f9125894393b9e28c2e492a51dfc35866b61035bba511429f3410488da2893853e0077f1906171577206b488390a4cd171c3cd6ca297fe73d4a2454b78a0cfc2bdd43c8d23c4d3925017b2d32a420f29954f1d5a0db371b040b00bcf25e2a64e95b6a0beb319e7e5d41d67d8045b65294529ee83f70537f0487b33b79f636188c8f31139f960c97f4deb604f6c281cc6293ec04a7dcf34e7a9dda761f04be730d3cdd8d5dfb63d7971be8c01025d89d289d5524727ea1bfa8ae4fc4072aef55f4e9c40eebb851ccab69a4d77bb126f4d21db7b2a91f525d37d700e151d8a95bc27d070c38550d438dc5abd9b2bc17d3e3871c653e8910a37f3db4db354a0893d44c7c7141400e9ea6f0d8a52ec31b603f16d3ba52c91a9022c9adc7672f0a556eb315d97fe75c23db906755b9bfd2bc896c64eda139bd8b21c07a53003ac251e6eab83e07ccd24a8f47c396519f7aaf8a60821a25ae8dba91923dbee2340f309ac5c13f1777e2d30203ad6f1e5837631e2ea206e74d696fc6ac6136fee49494987b40fa8528ccf9f80a3d7301ed596338cb9107df00be8ad7f66d9021048ed9db9eb6d492babec7581f092636e38260325ded1ea7e3a5772e9dd8d2b26a892a24fa9dcdc66c1f93cd11514558935f90f8396d7cac5201e2122f96e4597c0aad4a95c6ff87982ecebe37be862c505eee713c1bb4d6c9ea177a3f65d63ae1cf5ca98df7a332de9f3c5a7ba4493abeec6e3cceee330a1d24abd2aa31566efacd34b823b4448acd9793e9d757af8d458c21b921c553b6e496ed2d2ef9579b11e3c8b77503893885006d2a80562bd5eccb94b45b3e6e366a1c36f5a5253a275300663143f6647e0161f1a657693b685c0b487a61a80ed7c4428a08f56938dabc08d39fa3c9cc6112653e1119a32b83ae1c0e300d726ee8f075e504e72b127244af841891022cbb14e9f4c893aa7316c99d3980385771134d981061ca0ab1561450f16e5109b62e45f2cd2f082390c7dd42714e0f3e078e534d719599bf496764b57c2198b8ab001479c2b1c42fba06fcf81ac9fa8454cd190a586addc4fa69f77a8602ccebc142d6985cf549af81ba3fad460d44bc7a91635b83d08f5bf4a265f93073bc9294602801fe2d24c95f1b4d83e059a873ab193e4a9ed557b222b0b9400d0e64bf9776f02adf9de64b9761d056f2c805b0a8bb283e28fe33d92ec750405e3a45acad50d1135c652a56b08b1fc22c7dc4c72c178b33fd3403979c0be3bafc70787dfc6a17dba623a77021dfc8ea5c5406b9dce72903a7e968dc79d92ac84db8fbfbad845bce73ebcfcdf0dc689400e5cd3cc3c5ea850ad7238a31cac3047b64b4f9f063e1d87e3ec27194fe44ca5f3233e8f1b412292a89c2566bcf9d56fb168c2285e3c1486ff7efd678cbe2b7df087759e341f14bd4e6dfa702ea4f3c6a3e6978288920e3a2d22512f6d9e275f5624b74af023a975e6b2a34f6bb43eac320cc96052c62fc610c790fee974c79f1076a887b313ab76dafa40f95c28a99208189021591513cb039598b6a8d387766d5c265ed5e569bb6e2a8566ca65c8c3b2406313ad6b88d063de9da86e5bd5b06cd916b44843adc72a96c35eb1f45c589ddd9592297b77e76f8d206d8fe5b5ad08b42c7b2799ec70df029c7500176610f2d75cf07faed9883394be019cb5f10c7ade57dfa6bb3ef17a9711daa06c0962b2d678a9a6c542b8ff0b1150bead6a31d6ec739f59d7bf1e54228230bfc57cd9af6a140aa6f9e7cda1a9af93ccbd0a9d7ea041c5183f94858172b634e234c98c4d1db74a6a963281b51f087cc6752dbd902624cd87063d8f4510e6ba14e6c32646c1ee042c9d4a2d9b3a7d56919e6ebe1543ef3699f5ea78b1abaebf34309075313612eea4fbc3454ef614f8ef97c230bfb594d958dd97c45dc873e7dea8cadf15b07668c2020bdb86319fb0ab43e5005be876ebede4a2c84c379f112fef71de1cfd965eb53175790d6398528530ec0d30cef803d668183eb8bc42793ba08e53d361d1395f7367f88d8e483b2f9bad152c9c2c9e734942b8305ab96c98177e987f29c824f60f58e3fc77768d2e5a32f5e9687dc41dea8ad40085cca39a027512e04bf32ba68a227d3cbf79035d78782474267d5cb3ca098575b8c11ec2a0a09f36785fa543dea63bb3b6b1c948780c0351ecb4e2e104e8604b8b42ba2177622a7156b47a3b3952d6156190ffa5aaa99992df562d3704a72c4179f03492e4b1d40540b38c010ddfb1ac9a0729920b2b0056782bd4a4a9358e67bc474f217702cac1d76dce6e04b6328ce44b5cc21a5b2905056cdbc2f65a51875165922c10388abd0ccf0fd0746a32e6865e25920bd07c1ca1f1f29ab61cec27458e6147a0c4fa17211826bbf2bad6b60c9fae18f32f63b518c04664fc1ca1cdd831cdfc24cff94a1ab37cf746226a2be749f68b23c5f2f1f44d5a52a592201b6b6f4927efe494e17734a6945bfa3dd822acae782411d5b3f88243f46c1efb6dee39cfa8a952067ba87205f5979c1540d40a14cf1dda9f58edf87b290ecbbbd84684828fc6a68d00ed29b9c4700a4cc2043a23f30165bc5899734a8dc4c5473cc85956457a72d5fa5317494339dfbda40f47c0d57d7c5f83021312c407fdcfe99fd01925b3d15bc53c92af24bed9141aea0748953b7c9341afefa96d64c77ff36a1d4b3e4dc5f07bfdc2b9be47b8dc2e6c593db2b965e8dffabefd7bcf898dd96757d7cc3025984a5ef7cf59030d5b6bdca33bcde91be016fcbbcc39f3303f0d5ddd8ae44828106d1dfc2d3587a369d52a70910b28e2a2a3de650161b8b901273fba50be35fac24a11299e2242d2be602281f1062340b62592df64ed0a1dc9d7c40c50ca94aaf9244c824260621ac26232649f32c434d93aeaabf89dc2134a7a328c5e6dcfbf40a91737bf5a95213be7d4b67b72be932e936c082b790c9b029967723efa86529c5ad084e0b454936a661ee69c225f1772b121edceb6b331fcaf728fc1095da8a133b97f060d68f8a944eff2dbb7a77b7665d697a05baa07c95b5d747b3f4087c06a89de22d27b52e250c8346cf2408e92b4b2436d8a84d022948e89e776d5b88b0695e37b9d5a300fbf965fcc4bde7301b65f4a7186bab8b963c95e2a643963e0d9e279cdd42ed6ff96fffe9ce4dd08d9b26cd9b96c6bdfaab92ccb204d9969b8710d1dca3c034f66f9c382d9071128c5dde8499843ae9cc0e25df664ecd07ee4c2c21cbd45a75bca8bee3f3a16274c3d8c0b904cd81b0e0ee308bf8b2c5ccc5833ba0ea3a88c0932fe6e3c791f82cb8916eaa08e86165a06eae78e05a4247163557887d45dfd8d66565410e6ec9475f067a133efc4788a55c568d0102b8a389897fe9756d9690cd1b2886747b4c2c98ceb12ea6d4141334f2e566af4402c2a22cc55debb707ea16d278be33024899f7cbfe4a0ad7ea8b1ccd4bd74625d58244c98a95f9525de0dbdd939110c351c1d58a2055652f647b1fc55195d6a46b6f776071e24e356007b6d0f0d79044af1f66d31f48fc01a858b66e02fa2564270dc7d28f31c14276f8d73e8ef18cdd9903bab484dee7776c2a2968276dcacbb447dcdd7cfb67808ea36bce07073bc111c15b1d89a82edd05a4c83c9fcc22e1ac4409f6c845e244faed7f58b88ebe3e9d53e00f73e9bd2fa85773673f76db00c6d48eca05bcfabd395041ea350636af9119051e2b4d30d3b88cb05416f4f493f7f98d219a0376ab95ceabc401d2701494190635aa9df85588647b2b0ddf0575a2fb23f05f2b36255436375618db0712f982ec42b2967c6a767e7fe4f8dbc6ccc686c6388c39386c2d67617450749435066fc7befe75136c658dae12b20ee09e3edcd3956c81106d854bb3cd67125450c1bf83ee04ca34e88cc33994af0ec4cff5ecd0d8c09e3a1c84293641faf338009ebb78f2f6195d7e36ed339b6a41a8103066a8bb5d1f50d3c353db933229eade89aae59ba858f9bb4b3eedbdcb2c20eaa816e74f4e4190820b3293c1bd2470c0f9b01cb3ae197ebf68430a2d35ce34c0bfad86da744d4e5a94153724e457cf98f36e39ade46cb34dd9c737dfaf854722199feacc9e5b13f7201a08d41df34631b3c6553f140c651837f7ae04ae11127007ca3ecdcae5c09ed7b1531ec6b68b9c78d55d340b7df65824f4f03e3c34bba87a8ac331fac341f51e6cf17169f32a88e3120ff9d4432da421ec61f92c75b92d522c2373ae5c0269142c6128a668e51a7613022b944fa40017131265ca399264fd3c5ecae0acdea1610c78b14c3f2b20f6e92d9e9108c999015381b4a5fa67b933afa822a60d49acc4e4196987a83ee48863905cea2215d669736999fb715f4e34ae3cb135b3c2e0357fa6ce1c773d7c7c20538946c3821c3bbec8e9143de099aa92bf3efa753b689f6deed7627abd722e02e20cbf49a83f5fbcec61d440939d04789b11b2d7589c8113eb65a84eb40e7cf963114cd73adf22e1139308d89a3f99922f6651ac0c61cfc4b0ebd899f0e56b73adc4e080fd5ce447417fdc68208c383ec66cda8df57093bf5232081221cb745259b01985032637a276045c43c91940c32c036aad94a96728e9f228e470004e4ee8181339b087c559af1fbc391f66ff912e79cc23eb99369e15c5ee203f6cafac8ef08f0df197bb845a40a14e3a51a8d0b9784ac54942e6bca6112c4d592caa1d292b9eeb355cfe710486f07d34164a11cfd7bce9959948a393a329b88f59b28afcf44415a5bbeb74d51976cc7c0273c88b96d14530abf8a5d4d7738ece46a620d817ddd25fbec2c017a2ff3f4651a4e370dabafb7d271416e5fbdc2a152a1725d2137ab9b4fe7693f735e60a9b5fe0daefdf79b40468b1e4366b05eec69b75095d7ee808afdc34183218d0934be0491ae659a7692b4907bfdd82fa288aa325fcab3df1cfd25af55312ca05fc56b42cded6f61d3dd9e9f79219560dc4e9de4347b8f804083317871cf7c44e4a4564474e5f987448043b240c632306e5193b985cc345dc67c2a72a752eb2bf621253a111ba9608947d2618430ca639776e7bf00810c5a9261760a2f8d26a328ebc051657c74c78b95906bf2b189e6633ac4341630b06ecb7e0d6a010b9c830280591ab786ae492b6464c8907890b9bdbb05ca0d45bd748d901ad3d5fea289de6f432f0a95a3d512a7280be0bf208ebb3624cb6fdfab9ed8fc0be8402897731d841991efc7d1fd546c4ee5e845866f7ca37e72f0143932d58a279af5fbdaf907dd1f2194d13bb7625bd928db1f03be38e21fed03a912cbd5f46d8ba686f11f60c042bd49e1e87ebc28c7816921b60c2af7d06e8e0fcf42bbe4c701a3bf0c309b4f18cc072800f1ba9d790390aaa8b843a2b0c989a782f935e2c5dd89efee615fbb825ecbb217bd2fdd4e02a84137c81d52b468fb5e673f7ba2cbbf51c83fdb77afbd2f57467e912369cd50cb9437383ff4f5c041f5c939a7d9375a86d70c86c482cc9682ffc4d6e9049eecd309144cd44ae2d3c605ce237096c6a410b523e103695cc7db7aa84373998abf7e838c09c7e44a74bf86a6c325b34446e528afa7e6690a1dfef16928febf33800696df662863f90c6061cb1d9c1a14502ec120ee77131f6978ee1ff97bfa8fda4aa5778a9e847fcbaac0e3a2e1e6f0061f51306a7b9426533526ebad4d5c0b2dc6ad69541d9deed02db63eabd48975ff7017fbc21b591e30f19b6e7ba616cdc767c03bfb1769b9dc5a4eb4200d787bed873d35accd9e3ed764db682bfe3a971144ffe981be464160893675d8f9a1cf3d536fa6519bd7884b716cbb25e345ce7879e8bb85db1bc70f8bf10fc29a0bb38ec0e428a956c960df57511bf0ede2887a9be36eb0507adc79d0785fb9435e48be9f7ab5f42d06cb2eebd4927769b72189ba570579276e063f25f025e6ad8b874625fc190f1084b64d51dc84eb39bfab52fb7dfec2e66c6273f2d47999c0cb7c93684cb49c9e107652bb533e902e51b48edf50bbf6c05fe4f0fcb3f566b080eab656ace21f454e57b122b13674d5685c762a938cb7bedbb56ea09ffc2926ef2a679048b86e48819e97bd9259ee71ba22e8155db2981f97596985acd13eeab4f2c7df63ae171ad79c9fae2184f9960832aa846fd25e23c4fa34f09c10ffe1de5a58f31e505288c07231073f04ac92e2338ae85428aa3f8f5534704adb615c00d5580ec76dda8f8954e8917a63b4aa55c513379275ed8b83f1cb32896be4b6771cfb218a57bcf18decc80d9a88e7a0e57160236aca369b8b24a5c238e4cb5f77525bb9427aa84a79b3603f8f81ad3e6c002489666c5857e9d8eb15f9dd70ccae786824338f96c1b25ff571348450bf39682f5ed02ab3e08440dc9e36e0b189c408d1f34009640fe6b7e550d040e9012010757cd381fa32d5ff9228ff72b9dd1570fe65b4db954adda4d6fb9215363defdcf2e0d44e8980a669dcccee65944519c5ced09dbf3cf0785617894908f751194b2384cc771bd65ebcf1895962b0c2dcb5e4bfc78fb27b162f2ef306d41099aa24423b752ab5e257bc83cb4fce728ac3e52173379976a1a271b3c5a0c447129e475c8afedf9b121eb2993e4450291954103823392f88666bcaaef357aa0f572a4303aea972b5fb4c1f56654f5aa0ddaea33617458d24caa5fdddd94d6d8714e43f5db6638e77c3a1f7d155a551ee3de5dde86fc0990e2969819d92913ccc49234c1cca3f3b61f3f048c43b97dc6bc592a810b33f77fda63395d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>私密</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>shell学习</title>
    <url>/2024/04/28/shell%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="什么是shell">什么是Shell?</h2>
<p>Shell是一种用户与计算机进行交互的文字接口，也是一种脚本语言。</p>
<hr>
<h2 id="shell有什么用？">Shell有什么用？</h2>
<p>允许用户执行程序，查找文件，操作文件，输入并获取某种半结构化的输出</p>
<hr>
<h2 id="shell的使用">Shell的使用</h2>
<p>注意：此教程使用于类Unix shell，例如 Bash 或 ZSH，所以如果你的电脑是Mac或者Linux系统，则可以直接开始学习。<br>
如果您的电脑是Windows系统，请使用Wsl或者Linus虚拟机。</p>
<h4 id="在shell中导航">在Shell中导航</h4>
<p>shell中的路径时一组被分割的目录，<code>/</code>代表系统的根目录。</p>
<p>路径分为相对路径与绝对路径。</p>
<p>相对路径指的是相对当前的目录的路径，当前工作目录可以用<code>pwd</code>命令来获取。</p>
<p>绝对路径都是以<code>/</code>开头，可以认为是仅凭借绝对路径就能够找到文件的位置(相对路径无法做到这一点)</p>
<p>在相对路径表示中,<code>.</code>表示当前目录，<code>..</code>表示上级目录。</p>
<p>切换工作目录用<code>cd</code>操作来完成，格式为<code>cd 路径</code></p>
<p>下面举几个例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd .. # 进入上级目录<br>pwd # 显示当前目录<br>/mnt/d/Onedrive # 当前目录<br> cd ./桌面 # 进入桌面目录<br>pwd # 查看当前目录<br>/mnt/d/Onedrive/桌面 # 当前目录<br></code></pre></td></tr></table></figure>
<p>以上操作完成了切入桌面这一目录的操作。</p>
<hr>
<h4 id="ls命令">ls命令</h4>
<p>作用：查看指定目录下包含哪些文件。</p>
<p>语法：<code>ls 路径</code></p>
<p>如果没有指定参数，ls打印当前目录下的文件</p>
<hr>
<h4 id="标记和选项">标记和选项</h4>
<p>什么是标记和选项呢？它们以<code>-</code>开头，可以改变程序的行为。</p>
<p>通常，在执行程序的时候使用<code>-h</code>或者<code>-help</code>来打印帮助信息。</p>
<p>下面举一个使用标记和选项的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls -l ./文件夹合集<br></code></pre></td></tr></table></figure>
<p>通过<code>ls -help</code>中的帮助信息可以知道<code>ls -l</code>的作用是更加详细地列出目录文件或文件夹下的信息。</p>
<p>当我输入这个指令后，交互界面会打印出例如以下的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">drwxrwxrwx 1 borwin borwin 4096 Mar 15 01:15  my_python<br>drwxrwxrwx 1 borwin borwin 4096 Mar  9 22:29  pytorch学习<br></code></pre></td></tr></table></figure>
<p>前面一串字符串中d表示文件夹合集是一个目录，然后接下来的九个字符，每三个字符一组(rwx),它们分别代表了文件所有者、用户组以及其它所有人具有的权限。</p>
<p>r代表可读权限，w代表可写权限，x代表可执行权限(搜索权限)，如果不具有该权限，系统会打印出<code>r-x</code>之类的字符串，代表不具有修改权限。</p>
<hr>
<h4 id="mv命令">mv命令</h4>
<p>作用：为文件或者目录重命名，或者将文件或目录移动到其它位置。</p>
<p>语法：<br>
<code>mv [options] source dest</code></p>
<p><code>mv [options] source... directory</code></p>
<p>对options中的参数说明：</p>
<ul>
<li>-b: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。</li>
<li>-i: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。</li>
<li>-f: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。</li>
<li>-n: 不要覆盖任何已存在的文件或目录。</li>
<li>-u：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</li>
</ul>
<p>mv参数的设置与运行结果一般有以下几种情况：</p>
<table>
<thead>
<tr>
<th>参数的设置</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>mv source_file(文件) dest_file(文件)</td>
<td>将源文件名 source_file 改为目标文件名 dest_file</td>
</tr>
<tr>
<td>mv source_file(文件) dest_directory(目录)</td>
<td>将文件 source_file 移动到目标目录 dest_directory 中</td>
</tr>
<tr>
<td>mv source_directory(目录) dest_directory(目录)</td>
<td>目录名 dest_directory 已存在，将 source_directory 移动到目录名 dest_directory 中；目录名 dest_directory 不存在则 source_directory 改名为目录名 dest_directory</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="cp命令">cp命令</h4>
<p>作用:复制文件或者目录(包含粘贴操作)</p>
<p>语法：<code>cp [options] source dest</code></p>
<p>对options中的参数加以说明：</p>
<ul>
<li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于 dpR 参数组合。</li>
<li>-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。</li>
<li>-r 或 --recursive：用于复制目录及其所有的子目录和文件，如果要复制目录，需要使用该选项</li>
<li>-i 或 --interactive：在复制前提示确认，如果目标文件已存在，则会询问是否覆盖，回答 y 时目标文件将被覆盖。</li>
<li>-u 或 --update：仅复制源文件中更新时间较新的文件。</li>
<li>-v 或 --verbose：显示详细的复制过程。</li>
<li>-p 或 --preserve：保留源文件的权限、所有者和时间戳信息。</li>
<li>-f 或 --force：强制复制，即使目标文件已存在也会覆盖，而且不给出提示。</li>
<li>-l：不复制文件，只是生成链接文件。</li>
</ul>
<p>下面举几个例子：</p>
<table>
<thead>
<tr>
<th>参数的设置</th>
<th>运行的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>cp file.txt /path/to/destination/</td>
<td>将文件 file.txt 复制到目录 /path/to/destination/ 中</td>
</tr>
<tr>
<td>cp –r test/ newtest</td>
<td>将当前目录 test/ 下的所有文件复制到新目录 newtest 下</td>
</tr>
<tr>
<td>cp -i file.txt /path/to/destination/</td>
<td>复制文件，并在目标文件已存在时进行确认</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="mkdir命令">mkdir命令</h4>
<p>作用：创建目录</p>
<p>语法：<code>mkdir [-p] dirName</code></p>
<p>参数说明：-p 确保目录名称存在，不存在的就建一个。</p>
<p>参数设置与运行结果：</p>
<table>
<thead>
<tr>
<th>参数的设置</th>
<th>运行的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>mkdir runoob</td>
<td>在工作目录下，建立一个名为 runoob 的子目录</td>
</tr>
<tr>
<td>mkdir -p runoob2/test</td>
<td>在工作目录下的 runoob2 目录中，建立一个名为 test 的子目录,若 runoob2 目录原本不存在，则建立一个</td>
</tr>
</tbody>
</table>
<p>注意：在上面的第二个例子中若不加 -p 参数，且原本 runoob2 目录不存在，则产生错误。</p>
<hr>
<h4 id="用户手册">用户手册</h4>
<p>如果想要知道关于程序参数、输入输出的信息，亦或是想要了解它们的工作方式，可以用<code>man</code>程序查看其用户手册。</p>
<p>例如<code>man ls</code>就能查看<code>ls</code>程序的用户手册</p>
<hr>
<h4 id="在程序之间创建连接">在程序之间创建连接</h4>
<p>在 shell 中，程序有两个主要的“流”：它们的输入流和输出流。 当程序尝试读取信息时，它们会从输入流中进行读取，当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是您的终端。也就是，您的键盘作为输入，显示器作为输出。 但是，我们也可以重定向这些流！</p>
<p>最简单的两种重定向是<code>&lt; file</code>与<code>&gt; file</code>,分别为程序的输入重定向与输出的重定向</p>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">missing:~$ echo hello &gt; hello.txt<br>missing:~$ cat hello.txt<br>hello<br>missing:~$ cat &lt; hello.txt<br>hello<br>missing:~$ cat &lt; hello.txt &gt; hello2.txt<br>missing:~$ cat hello2.txt<br>hello<br></code></pre></td></tr></table></figure>
<p>除此之外，还可以使用<code>&gt;&gt;</code>来进行文件的最佳操作（即在文件的末尾追加内容）</p>
<p>重定向还可以依赖于管道<code>|</code>来将一个程序的输出于另一个程序的输入连接起来</p>
<p>举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">missing:~$ ls -l / | tail -n1<br>drwxr-xr-x 1 root  root  4096 Jun 20  2019 var<br>missing:~$ curl --head --silent google.com | grep --ignore-case content-length | cut --delimiter=&#x27; &#x27; -f2<br>219<br></code></pre></td></tr></table></figure>
<hr>
<h4 id="sudo命令">sudo命令</h4>
<p>作用:以管理者的身份来执行程序，不会受到权限的限制</p>
<hr>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>基础工具</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数据结构</title>
    <url>/2024/05/01/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/2024/04/28/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="快排">快排</h2>
<p>时间复杂度为O(nlogn)</p>
<p>算法概述：快排排序算法的核心是分治算法，往细一点讲就是：指定一个中间值，对序列进行划分，左部分全部小于该中间值，右部分全部大于中间值</p>
<p>之后再对所划分成的两个部分再进行划分（递归处理），最后达成排序的效果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid=a[l+r&gt;&gt;<span class="hljs-number">1</span>],le=l<span class="hljs-number">-1</span>,re=r+<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span>(le&lt;re)<br>    &#123;<br>        <span class="hljs-keyword">do</span> le++; <span class="hljs-keyword">while</span>(a[le]&lt;mid);<br>        <span class="hljs-keyword">do</span> ri--; <span class="hljs-keyword">while</span>(a[ri]&gt;mid);<br>        <span class="hljs-keyword">if</span>(le&lt;ri)<span class="hljs-built_in">swap</span>(a[le],a[ri]);<br>    &#125;<br>    <br>    <span class="hljs-built_in">quick_sort</span>(l,re);<br>    <span class="hljs-built_in">quick_sort</span>(re+<span class="hljs-number">1</span>,r);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可能会有人对以下递归中的参数有所疑问</p>
<p><code>quick_sort(l,re); quick_sort(re+1,r);</code></p>
<p>re指向的是从右到左的第一个小于mid的数，相当于要对从l到re进行排序，从re+1到r进行排序,这样解释是不是容易懂一些了呢？</p>
<hr>
<h2 id="归并排序">归并排序</h2>
<p>时间复杂度:O(nlogn)</p>
<p>分治的思想，及将序列分成两个部分，将这两个部分分别排序,之后合并为一个序列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],l,r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l&gt;=r)<span class="hljs-keyword">return</span>;<span class="hljs-comment">//递归结束条件</span><br>    <br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>,le=l,ri=mid+<span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-built_in">merge_sort</span>(a,l,mid);<span class="hljs-built_in">merge_sort</span>(a,mid+<span class="hljs-number">1</span>,r);<span class="hljs-comment">//分别排序</span><br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt;c;<span class="hljs-comment">//用于暂存合并后的排序好的数组</span><br>    <br>    <span class="hljs-keyword">while</span>(le&lt;ri)<span class="hljs-comment">//合并数组</span><br>        <span class="hljs-keyword">if</span>(a[le]&lt;=a[ri])c.<span class="hljs-built_in">push_back</span>(a[le++]);<br>        <span class="hljs-keyword">else</span> c.<span class="hljs-built_in">push_back</span>(a[ri++]);<br>    <br>    <span class="hljs-comment">//可能会出现一边没有填入vector完的情况</span><br>    <span class="hljs-keyword">while</span>(le&lt;=mid)c.<span class="hljs-built_in">push_back</span>(a[le++]);<br>    <span class="hljs-keyword">while</span>(ri&lt;=r)c.<span class="hljs-built_in">push_back</span>(a[ri++]);<br>    <br>    <span class="hljs-comment">//将暂存的数据填入原来的数组中</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=l,k=<span class="hljs-number">0</span>;i&lt;=r;i++,k++)a[i]=c[k];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其实在算法题中直接调用sort函数就行了(在数组比较短的时候是插入排序，数组比较长的时候是快排)，了解以上两种排序算法其实是加深对分治的理解，除了这几种排序算法外还有冒泡排序、选择排序等算法。</p>
<p>排序算法能够做到的最好的时间复杂度就是O(nlogn)了。</p>
<hr>
<h2 id="二分">二分</h2>
<p>此模板不用考虑mid+1或mid-1的情况,比Y总的模板好用qwq</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> l=<span class="hljs-number">-1</span>,r=n;<span class="hljs-comment">//n为数组长度,数组从0开始存储时这样初始化</span><br><span class="hljs-keyword">while</span>(l+<span class="hljs-number">1</span>!=r)<br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>())l=mid;<br>    <span class="hljs-keyword">else</span> r=mid;<br>&#125;<span class="hljs-comment">//最后根据实际情况选取l或者r作为结果</span><br></code></pre></td></tr></table></figure>
<h4 id="下面详细讲一下这串代码">下面详细讲一下这串代码:</h4>
<h5 id="为什么l的初始值为-1-r的初始值为n">为什么L的初始值为-1，R的初始值为N?</h5>
<p>这样赋值可以保证数组不会越界</p>
<h5 id="为什么循环结束的条件是while-l-1-r">为什么循环结束的条件是while(L+1!=R)?</h5>
<p>之前学过二分的小伙伴可能会发现，之前学的二分，他循环结束的条件是while(L&lt;R)</p>
<p>而这边给出的循环条件是while(L+1!=R) 其实，就是当L和R相邻的时候，循环就结束，而原本的while(L&lt;R)</p>
<p>是当两区间重合以后，循环才结束，所以之前我们需要判断对mid进行加一或者减一的操作，而且因为区间重合的问题，最后返回的L、R还要再进行判断，而这边的这个二分，因为区间反回的是不重合的两区间，只有L=mid和R=mid这两种情况，最后根据需要返回L或者R；</p>
<h5 id="为什么不会陷入死循环">为什么不会陷入死循环?</h5>
<p>对于比较奇葩的情况，比如数组大小为1或者2</p>
<p>比如int a[1],b[2];</p>
<p>由于我们是while(L+1!=R)结束循环，也就是当L和R相邻的时候结束条件</p>
<p>对于a[1],他的下标为0 此时L=-1，R=n也就是1</p>
<p>对于b[2],他的下标为0,1 此时L=-1，R=n也就是2</p>
<p>所以无论何种情况，初始的L+1始终小于R，历经循环后最终L和R相邻，不会出现一开始L就和R重合等情况导致出现while(L+1!=R)循环不能结束的情况</p>
<hr>
<h2 id="前缀和">前缀和</h2>
<p>前缀和算法适用于要经常取出数组中某一段的和的时候，能够将O(n)的取和操作优化为O(1)<br>
就像它的名字一样，前缀和就是从数组开头一直到某个序号处的所有元素的和。</p>
<h2 id="code-3"><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//假如有数组a[n+1],元素个数为n,从a[1]开始记录数据</span><br><span class="hljs-type">int</span> head_sum[n];<br>head_sum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)head_sum[i]=head_sum[i<span class="hljs-number">-1</span>]+a[i];<br></code></pre></td></tr></table></figure></h2>
<h2 id="差分">差分</h2>
<p>差分数组可以说是取前缀的逆运算，差分数组的前缀和数组为原数组，差分用于对某一段连续的区间进行加减操作</p>
<h2 id="code-4"><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sub[n];<br>sub[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)sub[i]=a[i]-a[i<span class="hljs-number">-1</span>];<br></code></pre></td></tr></table></figure></h2>
<h2 id="双指针">双指针</h2>
<p>双指针在多数情况下为左右指针与快慢指针的应用，当然也有一些情况需要灵活运用，下面举两个具体的例子，分别是左右指针与快慢指针的。</p>
<h4 id="左右指针">左右指针</h4>
<p>题目:输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>显然，这题用暴力做法的时间复杂度为O(n^2),但是如果我们用双指针就大不一样了(O(n))，见如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//假定一定存在这样的一对数的和为s,假设我们已知数组的长度为n,且从1开始存储数据</span><br><span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=n,res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(l&lt;r)<br>&#123;<br>    <span class="hljs-keyword">while</span>(a[l]+a[r]&gt;s &amp;&amp; l&lt;r)r--;<br>    <span class="hljs-keyword">if</span>(a[l]+a[r]==s)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,a[l],a[r]);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    l++;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>解释一下上面的代码中的为什么可以直接<code>l++;</code>,而不用重置r:</p>
<p>当右指针扫描至a[l]+a[r]&lt;s的位置时,满足a[l]+a[s+1]&gt;s,这时将l指针向右移动,由于a[l+1]&gt;a[l],所以此时a[l]+a[r+1]&gt;s,所以r保持不变，继续向前遍历是合理的。</p>
<h4 id="快慢指针">快慢指针</h4>
<p>举个简单的例子：输出链表中间位置的值.</p>
<p>何为快指针？何为慢指针？简单一点理解，走的快的为快指针，走的慢的为慢指针。</p>
<p>例如在这题中，我们将快指针与慢指针都初始化为头指针，然后画快指针一次向后移动两步，慢指针一次向后移动1步，这样，在快指针到达终点的时候，满指针恰好到达中间的位置。</p>
<p>由于过于简单，此处不用代码加以说明。</p>
<hr>
<h4 id="离散化">离散化</h4>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>利用shell解决的一些问题</title>
    <url>/2024/05/02/%E5%88%A9%E7%94%A8shell%E8%A7%A3%E5%86%B3%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-在-tmp-下新建一个名为-missing-的文件夹">1.在 /tmp 下新建一个名为 missing 的文件夹</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd ~/tmp<br>mkdir missing<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="2-用-touch-在-missing-文件夹中新建一个叫-semester-的文件">2.用 touch 在 missing 文件夹中新建一个叫 semester 的文件</h2>
<p>首先学习了一下touch的用法</p>
<p>作用：修改文件或者目录的时间属性，包括存取时间和更改时间。如果文件不存在，就建立一个新的文件</p>
<p>语法：<code>touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</code></p>
<p>参数说明：</p>
<ul>
<li>a 改变档案的读取时间记录。</li>
<li>m 改变档案的修改时间记录.</li>
<li>c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。</li>
<li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li>
<li>r 使用参考档的时间记录，与 --file 的效果一样。</li>
<li>d 设定时间与日期，可以使用各种不同的格式。</li>
<li>t 设定档案的时间记录，格式与 date 指令相同。</li>
<li>–no-create 不会建立新档案。</li>
<li>–help 列出指令格式。</li>
<li>–version 列出版本讯息。</li>
</ul>
<p>实例与运行效果：</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>运行效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>touch testfile</td>
<td>修改文件&quot;testfile&quot;的时间属性为当前系统时间</td>
</tr>
<tr>
<td>touch file</td>
<td>使用指令&quot;touch&quot;时，如果指定的文件不存在，则将创建一个新的空白文件</td>
</tr>
</tbody>
</table>
<p>可以用<code>ls -l</code>来查看时间属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cd missing<br>touch semester<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="3-将以下内容一行一行地写入-semester-文件：">3.将以下内容一行一行地写入 semester 文件：</h2>
<p><code>#!/bin/sh</code></p>
<p><code>curl --head --silent https://missing.csail.mit.edu</code></p>
<p>这个题涉及到转义的问题，如果直接用双引号的话，!在双引号中也有特殊含义，下面详细讲一下shell中的转义问题。</p>
<p>shell中的转义有三种途径：<code>\</code> <code>''</code> 与 <code>&quot;&quot;</code></p>
<h4 id="三种转义方法的使用范围">三种转义方法的使用范围</h4>
<h5 id="1">1.<code>\</code></h5>
<p><code>\</code>的范围是最广的,几乎可以对所有的特殊字符进行转义</p>
<h5 id="2">2.<code>'</code></h5>
<p><code>'</code>将会对其所包含的内容不加修饰，转义出来的内容就是所包含的内容,一个字符也不会改变</p>
<h5 id="3">3.’&quot;’</h5>
<p><code>&quot;</code>的使用范围比<code>'</code>小，<code>&quot;</code>会先将所包含的内容在shell中运行之后再进行输出</p>
<p>例如&quot;tell me the date&quot;:这段字符中的date将会被shell运行，替换为当时的日期</p>
<p>此外，shell中的特殊字符都会保留有特殊含义，再显示之前都会对其评估</p>
<p>经以上总结，我们可以简单的写出这题的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo &#x27;#!/bin/sh<br> curl --head --silent https://missing.csail.mit.edu&#x27; &gt; semester.txt<br></code></pre></td></tr></table></figure>
<h2 id="4-使用-chmod-命令改变权限-使-semester-能够成功执行">4. 使用 chmod 命令改变权限，使 ./semester 能够成功执行</h2>
<p>在我们直接在命令行输入<code>.\semester</code>时,我们会得到<code>Permission denied</code>,这是由于权限不够。</p>
<p>在输入<code>ls -l</code>之后，我们得到<code>rw-r--r--</code>,发现没有搜索的权限，所以我们无法运行程序，这时我们需要<code>chmod</code>命令来改变权限</p>
<p><code>chmod</code></p>
<p>作用：控制用户对文件的权限的命令</p>
<p>语法：<code>chmod [-cfvR] [--help] [--version] mode file...</code></p>
<p>参数说明：</p>
<ul>
<li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是</li>
<li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限</li>
<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行</li>
<li>-c : 若该文件权限确实已经更改，才显示其更改动作</li>
<li>-f : 若该文件权限无法被更改也不要显示错误讯息</li>
<li>-v : 显示权限变更的详细资料</li>
<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)</li>
<li>–help : 显示辅助说明</li>
<li>–version : 显示版本</li>
</ul>
<p><img src="/picture/rwx.jpg" alt="示例"></p>
<p>如上面的图片，该变权限实际上就是改变指定区域的字符，改变方式有八进制方式与符号模式。</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>chmod ugo+r file1.txt</td>
<td>将文件 file1.txt 设为所有人皆可读取</td>
</tr>
<tr>
<td>chmod a+r file1.txt</td>
<td>将文件 file1.txt 设为所有人皆可读取</td>
</tr>
<tr>
<td>chmod -R a+r *</td>
<td>将目前目录下的所有文件与子目录皆设为任何人可读取</td>
</tr>
<tr>
<td>chmod 777 file</td>
<td>将该目录对与所有对象的权限都设为rwx</td>
</tr>
</tbody>
</table>
<p>所以解决这一题我们用如下的代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">chmod u+x ./semester # 让文件所有者有搜索的权限<br>./semester # 运行程序<br></code></pre></td></tr></table></figure>
<p>下面解释一下运行代码中第一行的<code>#!/bin/sh</code></p>
<p><code>#!</code>被称为Shebang(Hashbang),在文件中存在Shebang的情况下，类Unix操作系统的程序加载器会分析Shebang后的内容，将这些内容作为解释器指令，并调用该指令，并将载有Shebang的文件路径作为该解释器的参数。</p>
<p>所以在这里相当于这句话的作用是调用/bin/sh程序来执行下面的代码</p>
<h2 id="5-使用-和-将-semester-文件输出的最后更改日期信息-写入主目录下的-last-modified-txt-的文件中">5. 使用 | 和 &gt; ，将 semester 文件输出的最后更改日期信息，写入主目录下的 last-modified.txt 的文件中</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">./semester | grep last-modified &gt; ~/last-modified.txt<br></code></pre></td></tr></table></figure>
<p>借助将管道的输出信息输出给<code>grep</code>,然后<code>grep</code>查找输出中以<code>last-modified</code>开头的信息，然后重定向输出到主文件夹的<code>last-modified.txt</code>中</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>基础工具</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>第33次CCF认证题解</title>
    <url>/2024/05/09/%E7%AC%AC33%E6%AC%A1CCF%E8%AE%A4%E8%AF%81%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1-词频统计">1.词频统计</h2>
<p>简单题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> cnt[N];<span class="hljs-comment">//记录每个单词出现的次数</span><br><span class="hljs-type">int</span> cn[N];<span class="hljs-comment">//记录每个单词所出现的文章的个数</span><br><span class="hljs-type">int</span> flag[N]; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-type">int</span> count1,num;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<br>		cin&gt;&gt;count1;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=count1;j++)<br>		&#123;<br>			cin&gt;&gt;num;<br>			<span class="hljs-keyword">if</span>(!flag[num])<br>			&#123;<br>				cn[num]++;<br>				flag[num]=<span class="hljs-number">1</span>; <br>			&#125;<br>			cnt[num]++;<br>		&#125;<br>		<span class="hljs-built_in">memset</span>(flag,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(flag));<br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>	&#123;<br>		cout&lt;&lt;cn[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cnt[i]&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="相似度计算">相似度计算</h2>
<p>直接开set,没什么好说的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e4</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> cn,cnt;<span class="hljs-comment">//cn记录交集的单词数,cnt记录并集的单词数</span><br><span class="hljs-type">int</span> n,m; <br>string word1[N],word2[N];<br>set&lt;string&gt;bin,jiao,words1,words2;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<br>		cin&gt;&gt;word1[i];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;word1[i].<span class="hljs-built_in">length</span>();j++)<br>		&#123;<br>			<span class="hljs-keyword">if</span>(word1[i][j]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;word1[i][j]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)<br>			&#123;<br>				word1[i][j]=word1[i][j]-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>;<br>			&#125;<br>		&#125;<br>		bin.<span class="hljs-built_in">insert</span>(word1[i]);<br>		words1.<span class="hljs-built_in">insert</span>(word1[i]);<br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>	&#123;<br>		cin&gt;&gt;word2[i];<br>		<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;word2[i].<span class="hljs-built_in">length</span>();j++)<br>		&#123;<br>			<span class="hljs-keyword">if</span>(word2[i][j]&gt;=<span class="hljs-string">&#x27;A&#x27;</span>&amp;&amp;word2[i][j]&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)<br>			&#123;<br>				word2[i][j]=word2[i][j]-<span class="hljs-string">&#x27;A&#x27;</span>+<span class="hljs-string">&#x27;a&#x27;</span>;<br>			&#125;<br>		&#125;<br>		bin.<span class="hljs-built_in">insert</span>(word2[i]);<br>		words2.<span class="hljs-built_in">insert</span>(word2[i]);<br>	&#125;<br>	<br>	<span class="hljs-keyword">for</span>(set&lt;string&gt;::iterator it=words2.<span class="hljs-built_in">begin</span>();it!=words2.<span class="hljs-built_in">end</span>();it++)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(words1.<span class="hljs-built_in">find</span>(*it)!=words1.<span class="hljs-built_in">end</span>())cn++;<br>	&#125;<br>	<br>	cout&lt;&lt;cn&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>&lt;&lt;bin.<span class="hljs-built_in">size</span>();<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="3-化学方程式配平">3.化学方程式配平</h2>
<p>根据题意写代码就行了，这么简单的题我当时居然没拿100分，有点气人</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bit/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gauss</span><span class="hljs-params">(<span class="hljs-type">double</span> a[][<span class="hljs-number">50</span>], <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> hang, <span class="hljs-type">int</span> lie)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt;= hang || y &gt;= lie)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 用于判断第一列是否为空</span><br>    <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<span class="hljs-comment">//用于标记找到的第一个元素不为0的行号</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt; hang; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (a[i][y] != <span class="hljs-number">0</span>)<br>        &#123;<br>            flag = <span class="hljs-literal">false</span>;<br>            idx = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">true</span>)<br>        <span class="hljs-built_in">gauss</span>(a, x, y + <span class="hljs-number">1</span>, hang, lie);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//idx不为0时，需要将这一行与第一行换位置</span><br>        <span class="hljs-keyword">if</span> (idx != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lie; i++)<br>                <span class="hljs-built_in">swap</span>(a[idx][i], a[x][i]);<br>        &#125;<br>        <span class="hljs-comment">//对下面行中所有第一项不为0的行进行减操作</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = idx + <span class="hljs-number">1</span>; i &lt; hang; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = y+<span class="hljs-number">1</span>; j &lt; lie; j++)<br>                a[i][j] -= a[i][y] / a[x][y] * a[x][j];<br>            a[i][y] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">gauss</span>(a, x + <span class="hljs-number">1</span>, y + <span class="hljs-number">1</span>, hang, lie);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> a[<span class="hljs-number">50</span>][<span class="hljs-number">50</span>], cnt, q, k = <span class="hljs-number">0</span>, N = <span class="hljs-number">0</span>, flag = <span class="hljs-number">0</span>;<span class="hljs-comment">//二维数组a模拟矩阵</span><br>    string thing;<span class="hljs-comment">//存储每一个方程式</span><br>    set &lt;string&gt; s;<span class="hljs-comment">//存储出现过的元素，并对其去重</span><br>    map&lt;string, <span class="hljs-type">int</span>&gt; b;<span class="hljs-comment">//存储某个物质中某个元素所对应的序号，即在矩阵中的行数</span><br><br>    <span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(a));<br><br>    cin &gt;&gt; cnt;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)<span class="hljs-comment">//创建矩阵</span><br>    &#123;<br>        cin &gt;&gt; thing;<br>        q = <span class="hljs-number">0</span>;<br>        string temp = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (q &lt; thing.<span class="hljs-built_in">length</span>())<br>        &#123;<br>            temp = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">while</span> (q &lt; thing.<span class="hljs-built_in">length</span>() &amp;&amp; <span class="hljs-built_in">isalpha</span>(thing[q]))<br>            &#123;<br>                temp.<span class="hljs-built_in">push_back</span>(thing[q]);<br>                q++;<br>            &#125;<br>            s.<span class="hljs-built_in">insert</span>(temp);<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (q &lt; thing.<span class="hljs-built_in">length</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(thing[q]))<br>            &#123;<br>                x = x * <span class="hljs-number">10</span> + thing[q] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                q++;<br>            &#125;<br><br><br>            <span class="hljs-keyword">if</span> (!b.<span class="hljs-built_in">count</span>(temp))<span class="hljs-comment">//如果没出现过，则为其编号</span><br>            &#123;<br>                b[temp] = k++;<br>            &#125;<br>            a[b[temp]][i] = x;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*for (int i = 0; i &lt; s.size(); i++)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        for (int j = 0; j &lt; cnt; j++)</span><br><span class="hljs-comment">            cout &lt;&lt; a[i][j] &lt;&lt; &#x27; &#x27;;</span><br><span class="hljs-comment">        cout &lt;&lt; endl;</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-comment">//cout &lt;&lt; &#x27;\n&#x27; &lt;&lt; &#x27;\n&#x27;;</span><br><br>    <span class="hljs-built_in">gauss</span>(a, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>(), cnt);<span class="hljs-comment">//高斯消元</span><br><br>    <span class="hljs-comment">/*for (int i = 0; i &lt; s.size(); i++)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        for (int j = 0; j &lt; cnt; j++)</span><br><span class="hljs-comment">            cout &lt;&lt; a[i][j] &lt;&lt; &#x27; &#x27;;</span><br><span class="hljs-comment">        cout &lt;&lt; endl;</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[i][j] != <span class="hljs-number">0</span>)<br>            &#123;<br>                N++;<br>                flag = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (N &lt; cnt)<br>        cout &lt;&lt; <span class="hljs-string">&quot;Y&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;N&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">while</span> (n--)<br>        <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="4-十滴水">4.十滴水</h2>
<p>关心水滴的坐标大小关系，并不关心其具体值是多少。所以，直接用set 存下所有的坐标，每次用 lowerbound 查找目标水滴，然后再将其左右两端进行更新。如果有多个待删水滴，则使用一个优先队列，按照下标排序即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//题目大体思路：用一个结构体来存储有水滴的格子的序号跟水滴数</span><br><span class="hljs-comment">//用set存储该结构体，之后每进行一次操作便将操作的结点在set中删除，并依次向左和向右执行操作</span><br><span class="hljs-comment">//在考虑哪些水滴会炸裂时，用优先队列存储水滴数大于等于5的点，方便每次都是最左边的点先裂开，且能够对所有的点进行处理，不会遗漏</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>	<span class="hljs-type">int</span> x, w;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node&amp; a)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x &lt; a.x;<br>	&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> node&amp; a)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x == a.x &amp;&amp; w == a.w;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> c, m, n;<br>	cin &gt;&gt; c &gt;&gt; m &gt;&gt; n;<br><br>	set&lt;node&gt;s;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)<br>	&#123;<br>		<span class="hljs-type">int</span> x, w;<br>		cin &gt;&gt; x &gt;&gt; w;<br><br>		s.<span class="hljs-built_in">insert</span>(&#123; x,w &#125;);<br><br>	&#125;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		<span class="hljs-type">int</span> p;<br>		cin &gt;&gt; p;<br><br>		<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">lower_bound</span>(&#123; p,<span class="hljs-number">0</span> &#125;);<span class="hljs-comment">//找到要裂开的点</span><br>		<span class="hljs-keyword">auto</span> temp = *it;<br>		s.<span class="hljs-built_in">erase</span>(it);<br>		temp.w++;<br>		s.<span class="hljs-built_in">insert</span>(temp);<br><br>		set&lt;<span class="hljs-type">int</span>&gt;ans;<span class="hljs-comment">//用于存储要裂开的点</span><br><br>		<span class="hljs-keyword">if</span> (temp.w &gt;= <span class="hljs-number">5</span>)ans.<span class="hljs-built_in">insert</span>(temp.x);<br><br>		<span class="hljs-keyword">while</span> (!ans.<span class="hljs-built_in">empty</span>())<br>		&#123;<br>			<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">lower_bound</span>(&#123;*ans.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">0</span>&#125;);<br>			ans.<span class="hljs-built_in">erase</span>(ans.<span class="hljs-built_in">begin</span>());<br>			<span class="hljs-keyword">if</span> (it != s.<span class="hljs-built_in">begin</span>())<br>			&#123;<br>				<span class="hljs-keyword">auto</span> it1 = it ;<br>				it1--;<br>				<span class="hljs-keyword">auto</span> temp = *it1;<br>				s.<span class="hljs-built_in">erase</span>(it1);<br>				temp.w++;<br>				s.<span class="hljs-built_in">insert</span>(temp);<br>				<span class="hljs-keyword">if</span> (temp.w &gt;= <span class="hljs-number">5</span>)ans.<span class="hljs-built_in">insert</span>(temp.x);<br>			&#125;<br>			<span class="hljs-keyword">auto</span> it2 = it;<br>			it2++;<br>			<span class="hljs-keyword">if</span> (it2 != s.<span class="hljs-built_in">end</span>())<br>			&#123;<br>				<span class="hljs-keyword">auto</span> temp = *it2;<br>				s.<span class="hljs-built_in">erase</span>(it2);<br>				temp.w++;<br>				s.<span class="hljs-built_in">insert</span>(temp);<br>				<span class="hljs-keyword">if</span> (temp.w &gt;= <span class="hljs-number">5</span>)ans.<span class="hljs-built_in">insert</span>(temp.x);<br>			&#125;<br>			s.<span class="hljs-built_in">erase</span>(it);<br>		&#125;<br>		cout &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>csp</tag>
      </tags>
  </entry>
  <entry>
    <title>离散数学（上）期末复习</title>
    <url>/2024/05/07/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%8A%EF%BC%89%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="思维导图持续更新中">思维导图持续更新中…</h2>
<p><a href="https://gitmind.cn/app/docs/m3jtdt2i">离散数学（上）</a></p>
<p>点击以上链接😉</p>
]]></content>
      <tags>
        <tag>离散数学</tag>
      </tags>
  </entry>
  <entry>
    <title>结构体运算符重定向</title>
    <url>/2024/05/09/%E7%BB%93%E6%9E%84%E4%BD%93%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    <content><![CDATA[<h4 id="举个例子">举个例子</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>	<span class="hljs-type">int</span> x, w;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node&amp; a)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x &lt; a.x;<br>	&#125;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> node&amp; a)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x == a.x &amp;&amp; w == a.w;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>上式重定向了小于和等于运算符</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度算法</title>
    <url>/2024/05/01/%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
